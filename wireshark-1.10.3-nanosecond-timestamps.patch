diff --git a/acinclude.m4 b/acinclude.m4
index f962022..719bdbe 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -615,7 +615,7 @@ install a newer version of the header file.])
 	  AC_CHECK_FUNCS(pcap_datalink_val_to_description)
 	  AC_CHECK_FUNCS(pcap_list_datalinks pcap_set_datalink pcap_lib_version)
 	  AC_CHECK_FUNCS(pcap_get_selectable_fd pcap_free_datalinks)
-	  AC_CHECK_FUNCS(pcap_create bpf_image)
+	  AC_CHECK_FUNCS(pcap_create bpf_image pcap_set_tstamp_precision)
 	fi
 	LIBS="$ac_save_LIBS"
 ])
diff --git a/cmake/modules/FindPCAP.cmake b/cmake/modules/FindPCAP.cmake
index 1d3c1b6..bde07d7 100644
--- a/cmake/modules/FindPCAP.cmake
+++ b/cmake/modules/FindPCAP.cmake
@@ -121,6 +121,7 @@ CHECK_FUNCTION_EXISTS("pcap_get_selectable_fd" HAVE_PCAP_GET_SELECTABLE_FD)
 CHECK_FUNCTION_EXISTS("pcap_lib_version" HAVE_PCAP_LIB_VERSION)
 CHECK_FUNCTION_EXISTS("pcap_list_datalinks" HAVE_PCAP_LIST_DATALINKS)
 CHECK_FUNCTION_EXISTS("pcap_set_datalink" HAVE_PCAP_SET_DATALINK)
+CHECK_FUNCTION_EXISTS("pcap_set_tstamp_precision" HAVE_PCAP_SET_TSTAMP_PRECISION)
 # Remote pcap checks
 CHECK_FUNCTION_EXISTS("pcap_open" H_PCAP_OPEN)
 CHECK_FUNCTION_EXISTS("pcap_findalldevs_ex" H_FINDALLDEVS_EX)
diff --git a/cmakeconfig.h.in b/cmakeconfig.h.in
index 2ef36d1..fee55c5 100644
--- a/cmakeconfig.h.in
+++ b/cmakeconfig.h.in
@@ -252,6 +252,9 @@
 #cmakedefine HAVE_PCAP_REMOTE 1
 #cmakedefine HAVE_REMOTE 1
 
+/* Define to 1 if you have the `pcap_set_tstamp_precision' function. */
+#cmakedefine HAVE_PCAP_SET_TSTAMP_PRECISION 1
+
 /* Define to 1 if you have the <portaudio.h> header file. */
 #cmakedefine HAVE_PORTAUDIO_H 1
 
diff --git a/dumpcap.c b/dumpcap.c
index adba93d..bae3fbf 100644
--- a/dumpcap.c
+++ b/dumpcap.c
@@ -641,7 +641,12 @@ relinquish_all_capabilities(void)
 #endif
 
 static pcap_t *
-open_capture_device(interface_options *interface_opts,
+open_capture_device(capture_options *capture_opts
+#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION
+                    _U_
+#endif
+                    ,
+                    interface_options *interface_opts,
                     char (*open_err_str)[PCAP_ERRBUF_SIZE])
 {
     pcap_t *pcap_h;
@@ -714,6 +719,31 @@ open_capture_device(interface_options *interface_opts,
             pcap_set_promisc(pcap_h, interface_opts->promisc_mode);
             pcap_set_timeout(pcap_h, CAP_READ_TIMEOUT);
 
+#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
+            /*
+             * If we're writing pcap-ng files, try to enable
+             * nanosecond-resolution capture; any code that
+             * can read pcap-ng files must be able to handle
+             * nanosecond-resolution time stamps.
+             *
+             * If we're writing pcap files, don't try to enable
+             * nanosecond-resolution capture, as not all code
+             * that reads pcap files recognizes the nanosecond-
+             * resolution pcap file magic number.
+             */
+            if (capture_opts->use_pcapng) {
+                /*
+                 * The only errors this is documenting as returning
+                 * are PCAP_ERROR_TSTAMP_PRECISION_NOTSUP, which jus
+                 * means we can't do nanosecond precision on this adapter,
+                 * in which case we just live with whatever resolution
+                 * we get by default, and PCAP_ERROR_ACTIVATED, which
+                 * can't happen as we haven't activated the pcap_t yet.
+                 */
+                pcap_set_tstamp_precision(pcap_h, PCAP_TSTAMP_PRECISION_NANO);
+            }
+#endif
+
             g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_DEBUG,
                   "buffersize %d.", interface_opts->buffer_size);
             if (interface_opts->buffer_size != 0) {
@@ -913,7 +943,7 @@ show_filter_code(capture_options *capture_opts)
 
     for (j = 0; j < capture_opts->ifaces->len; j++) {
         interface_opts = g_array_index(capture_opts->ifaces, interface_options, j);
-        pcap_h = open_capture_device(&interface_opts, &open_err_str);
+        pcap_h = open_capture_device(capture_opts, &interface_opts, &open_err_str);
         if (pcap_h == NULL) {
             /* Open failed; get messages */
             get_capture_device_open_failure_messages(open_err_str,
@@ -2680,10 +2710,16 @@ capture_loop_open_input(capture_options *capture_opts, loop_data *ld,
         g_array_append_val(ld->pcaps, pcap_opts);
 
         g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_DEBUG, "capture_loop_open_input : %s", interface_opts.name);
-        pcap_opts->pcap_h = open_capture_device(&interface_opts, &open_err_str);
+        pcap_opts->pcap_h = open_capture_device(capture_opts, &interface_opts, &open_err_str);
 
         if (pcap_opts->pcap_h != NULL) {
             /* we've opened "iface" as a network device */
+
+#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION
+        /* Find out if we're getting nanosecond-precision time stamps */
+        pcap_opts->ts_nsec = pcap_get_tstamp_precision(pcap_opts->pcap_h) == PCAP_TSTAMP_PRECISION_NANO;
+#endif
+
 #ifdef _WIN32
             /* try to set the capture buffer size */
             if (interface_opts.buffer_size > 1 &&
diff --git a/editcap.c b/editcap.c
index 9ba8245..8caa1bf 100644
--- a/editcap.c
+++ b/editcap.c
@@ -125,7 +125,6 @@ fd_hash_t fd_hash[MAX_DUP_DEPTH];
 int dup_window = DEFAULT_DUP_DEPTH;
 int cur_dup_entry = 0;
 
-#define ONE_MILLION 1000000
 #define ONE_BILLION 1000000000
 
 /* Weights of different errors we can introduce */
@@ -143,7 +142,7 @@ int cur_dup_entry = 0;
 
 
 struct time_adjustment {
-  struct timeval tv;
+  nstime_t tv;
   int is_negative;
 };
 
@@ -368,18 +367,18 @@ set_time_adjustment(char *optarg_str_p)
           exit(1);
       }
   }
-  time_adj.tv.tv_sec = val;
+  time_adj.tv.secs = val;
 
   /* now collect the partial seconds, if any */
   if (*frac != '\0') {             /* chars left, so get fractional part */
     val = strtol(&(frac[1]), &end, 10);
-    /* if more than 6 fractional digits truncate to 6 */
-    if((end - &(frac[1])) > 6) {
-        frac[7] = 't'; /* 't' for truncate */
+    /* if more than 9 fractional digits truncate to 9 */
+    if((end - &(frac[1])) > 9) {
+        frac[10] = 't'; /* 't' for truncate */
         val = strtol(&(frac[1]), &end, 10);
     }
     if (*frac != '.' || end == NULL || end == frac
-        || val < 0 || val > ONE_MILLION || val == LONG_MIN || val == LONG_MAX) {
+        || val < 0 || val > ONE_BILLION || val == LONG_MIN || val == LONG_MAX) {
       fprintf(stderr, "editcap: \"%s\" isn't a valid time adjustment\n",
               optarg_str_p);
       exit(1);
@@ -390,15 +389,15 @@ set_time_adjustment(char *optarg_str_p)
   }
 
   /* adjust fractional portion from fractional to numerator
-   * e.g., in "1.5" from 5 to 500000 since .5*10^6 = 500000 */
+   * e.g., in "1.5" from 5 to 500000000 since .5*10^9 = 500000000 */
   if (frac && end) {            /* both are valid */
     frac_digits = end - frac - 1;   /* fractional digit count (remember '.') */
-    while(frac_digits < 6) {    /* this is frac of 10^6 */
+    while(frac_digits < 9) {    /* this is frac of 10^9 */
       val *= 10;
       frac_digits++;
     }
   }
-  time_adj.tv.tv_usec = (int)val;
+  time_adj.tv.nsecs = (int) val;
 }
 
 static void
@@ -443,18 +442,18 @@ set_strict_time_adj(char *optarg_str_p)
           exit(1);
       }
   }
-  strict_time_adj.tv.tv_sec = val;
+  strict_time_adj.tv.secs = val;
 
   /* now collect the partial seconds, if any */
   if (*frac != '\0') {             /* chars left, so get fractional part */
     val = strtol(&(frac[1]), &end, 10);
-    /* if more than 6 fractional digits truncate to 6 */
-    if((end - &(frac[1])) > 6) {
-        frac[7] = 't'; /* 't' for truncate */
+    /* if more than 9 fractional digits truncate to 9 */
+    if((end - &(frac[1])) > 9) {
+        frac[10] = 't'; /* 't' for truncate */
         val = strtol(&(frac[1]), &end, 10);
     }
     if (*frac != '.' || end == NULL || end == frac
-        || val < 0 || val > ONE_MILLION || val == LONG_MIN || val == LONG_MAX) {
+        || val < 0 || val > ONE_BILLION || val == LONG_MIN || val == LONG_MAX) {
       fprintf(stderr, "editcap: \"%s\" isn't a valid time adjustment\n",
               optarg_str_p);
       exit(1);
@@ -465,15 +464,15 @@ set_strict_time_adj(char *optarg_str_p)
   }
 
   /* adjust fractional portion from fractional to numerator
-   * e.g., in "1.5" from 5 to 500000 since .5*10^6 = 500000 */
+   * e.g., in "1.5" from 5 to 500000000 since .5*10^9 = 500000000 */
   if (frac && end) {            /* both are valid */
     frac_digits = end - frac - 1;   /* fractional digit count (remember '.') */
-    while(frac_digits < 6) {    /* this is frac of 10^6 */
+    while(frac_digits < 9) {    /* this is frac of 10^9 */
       val *= 10;
       frac_digits++;
     }
   }
-  strict_time_adj.tv.tv_usec = (int)val;
+  strict_time_adj.tv.nsecs = (int) val;
 }
 
 static void
@@ -1319,14 +1318,14 @@ main(int argc, char *argv[])
                  */
                 /* printf("++out of order, need to adjust this packet!\n"); */
                 snap_phdr = *phdr;
-                snap_phdr.ts.secs = previous_time.secs + strict_time_adj.tv.tv_sec;
+                snap_phdr.ts.secs = previous_time.secs + strict_time_adj.tv.secs;
                 snap_phdr.ts.nsecs = previous_time.nsecs;
-                if (snap_phdr.ts.nsecs + strict_time_adj.tv.tv_usec * 1000 > ONE_MILLION * 1000) {
+                if (snap_phdr.ts.nsecs + strict_time_adj.tv.nsecs > ONE_BILLION) {
                   /* carry */
                   snap_phdr.ts.secs++;
-                  snap_phdr.ts.nsecs += (strict_time_adj.tv.tv_usec - ONE_MILLION) * 1000;
+                  snap_phdr.ts.nsecs += strict_time_adj.tv.nsecs - ONE_BILLION;
                 } else {
-                  snap_phdr.ts.nsecs += strict_time_adj.tv.tv_usec * 1000;
+                  snap_phdr.ts.nsecs += strict_time_adj.tv.nsecs;
                 }
                 phdr = &snap_phdr;
               }
@@ -1337,14 +1336,14 @@ main(int argc, char *argv[])
                * packet's timestamp plus delta.
                */
               snap_phdr = *phdr;
-              snap_phdr.ts.secs = previous_time.secs + strict_time_adj.tv.tv_sec;
+              snap_phdr.ts.secs = previous_time.secs + strict_time_adj.tv.secs;
               snap_phdr.ts.nsecs = previous_time.nsecs;
-              if (snap_phdr.ts.nsecs + strict_time_adj.tv.tv_usec * 1000 > ONE_MILLION * 1000) {
+              if (snap_phdr.ts.nsecs + strict_time_adj.tv.nsecs > ONE_BILLION) {
                 /* carry */
                 snap_phdr.ts.secs++;
-                snap_phdr.ts.nsecs += (strict_time_adj.tv.tv_usec - ONE_MILLION) * 1000;
+                snap_phdr.ts.nsecs += strict_time_adj.tv.nsecs - ONE_BILLION;
               } else {
-                snap_phdr.ts.nsecs += strict_time_adj.tv.tv_usec * 1000;
+                snap_phdr.ts.nsecs += strict_time_adj.tv.nsecs;
               }
               phdr = &snap_phdr;
             }
@@ -1355,32 +1354,32 @@ main(int argc, char *argv[])
 
         /* assume that if the frame's tv_sec is 0, then
          * the timestamp isn't supported */
-        if (phdr->ts.secs > 0 && time_adj.tv.tv_sec != 0) {
+        if (phdr->ts.secs > 0 && time_adj.tv.secs != 0) {
           snap_phdr = *phdr;
           if (time_adj.is_negative)
-            snap_phdr.ts.secs -= time_adj.tv.tv_sec;
+            snap_phdr.ts.secs -= time_adj.tv.secs;
           else
-            snap_phdr.ts.secs += time_adj.tv.tv_sec;
+            snap_phdr.ts.secs += time_adj.tv.secs;
           phdr = &snap_phdr;
         }
 
         /* assume that if the frame's tv_sec is 0, then
          * the timestamp isn't supported */
-        if (phdr->ts.secs > 0 && time_adj.tv.tv_usec != 0) {
+        if (phdr->ts.secs > 0 && time_adj.tv.nsecs != 0) {
           snap_phdr = *phdr;
           if (time_adj.is_negative) { /* subtract */
-            if (snap_phdr.ts.nsecs/1000 < time_adj.tv.tv_usec) { /* borrow */
+            if (snap_phdr.ts.nsecs < time_adj.tv.nsecs) { /* borrow */
               snap_phdr.ts.secs--;
-              snap_phdr.ts.nsecs += ONE_MILLION * 1000;
+              snap_phdr.ts.nsecs += ONE_BILLION;
             }
-            snap_phdr.ts.nsecs -= time_adj.tv.tv_usec * 1000;
+            snap_phdr.ts.nsecs -= time_adj.tv.nsecs;
           } else {                  /* add */
-            if (snap_phdr.ts.nsecs + time_adj.tv.tv_usec * 1000 > ONE_MILLION * 1000) {
+            if (snap_phdr.ts.nsecs + time_adj.tv.nsecs > ONE_BILLION) {
               /* carry */
               snap_phdr.ts.secs++;
-              snap_phdr.ts.nsecs += (time_adj.tv.tv_usec - ONE_MILLION) * 1000;
+              snap_phdr.ts.nsecs += time_adj.tv.nsecs - ONE_BILLION;
             } else {
-              snap_phdr.ts.nsecs += time_adj.tv.tv_usec * 1000;
+              snap_phdr.ts.nsecs += time_adj.tv.nsecs;
             }
           }
           phdr = &snap_phdr;
diff --git a/epan/column-utils.c b/epan/column-utils.c
index 6ed9f85..8e89409 100644
--- a/epan/column-utils.c
+++ b/epan/column-utils.c
@@ -675,6 +675,7 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
 {
   struct tm *tmp;
   time_t then;
+  int tsprecision;
 
   if (fd->flags.has_ts) {
     then = fd->abs_ts.secs;
@@ -685,9 +686,33 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
   } else
     tmp = NULL;
   if (tmp != NULL) {
-      switch(timestamp_get_precision()) {
-      case TS_PREC_FIXED_SEC:
-      case TS_PREC_AUTO_SEC:
+      switch (timestamp_get_precision()) {
+        case TS_PREC_FIXED_SEC:
+            tsprecision = WTAP_TSPREC_SEC;
+            break;
+        case TS_PREC_FIXED_DSEC:
+            tsprecision = WTAP_TSPREC_DSEC;
+            break;
+        case TS_PREC_FIXED_CSEC:
+            tsprecision = WTAP_TSPREC_CSEC;
+            break;
+        case TS_PREC_FIXED_MSEC:
+            tsprecision = WTAP_TSPREC_MSEC;
+            break;
+        case TS_PREC_FIXED_USEC:
+            tsprecision = WTAP_TSPREC_USEC;
+            break;
+        case TS_PREC_FIXED_NSEC:
+            tsprecision = WTAP_TSPREC_NSEC;
+            break;
+        case TS_PREC_AUTO:
+            tsprecision = fd->tsprec;
+            break;
+        default:
+            g_assert_not_reached();
+      }
+      switch(tsprecision) {
+      case WTAP_TSPREC_SEC:
           g_snprintf(buf, COL_MAX_LEN,"%04d-%02d-%02d %02d:%02d:%02d",
              tmp->tm_year + 1900,
              tmp->tm_mon + 1,
@@ -696,8 +721,7 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
              tmp->tm_min,
              tmp->tm_sec);
           break;
-      case TS_PREC_FIXED_DSEC:
-      case TS_PREC_AUTO_DSEC:
+      case WTAP_TSPREC_DSEC:
           g_snprintf(buf, COL_MAX_LEN,"%04d-%02d-%02d %02d:%02d:%02d.%01d",
              tmp->tm_year + 1900,
              tmp->tm_mon + 1,
@@ -707,8 +731,7 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
              tmp->tm_sec,
              fd->abs_ts.nsecs / 100000000);
           break;
-      case TS_PREC_FIXED_CSEC:
-      case TS_PREC_AUTO_CSEC:
+      case WTAP_TSPREC_CSEC:
           g_snprintf(buf, COL_MAX_LEN,"%04d-%02d-%02d %02d:%02d:%02d.%02d",
              tmp->tm_year + 1900,
              tmp->tm_mon + 1,
@@ -718,8 +741,7 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
              tmp->tm_sec,
              fd->abs_ts.nsecs / 10000000);
           break;
-      case TS_PREC_FIXED_MSEC:
-      case TS_PREC_AUTO_MSEC:
+      case WTAP_TSPREC_MSEC:
           g_snprintf(buf, COL_MAX_LEN, "%04d-%02d-%02d %02d:%02d:%02d.%03d",
              tmp->tm_year + 1900,
              tmp->tm_mon + 1,
@@ -729,8 +751,7 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
              tmp->tm_sec,
              fd->abs_ts.nsecs / 1000000);
           break;
-      case TS_PREC_FIXED_USEC:
-      case TS_PREC_AUTO_USEC:
+      case WTAP_TSPREC_USEC:
           g_snprintf(buf, COL_MAX_LEN, "%04d-%02d-%02d %02d:%02d:%02d.%06d",
              tmp->tm_year + 1900,
              tmp->tm_mon + 1,
@@ -740,8 +761,7 @@ set_abs_date_time(const frame_data *fd, gchar *buf, gboolean local)
              tmp->tm_sec,
              fd->abs_ts.nsecs / 1000);
           break;
-      case TS_PREC_FIXED_NSEC:
-      case TS_PREC_AUTO_NSEC:
+      case WTAP_TSPREC_NSEC:
           g_snprintf(buf, COL_MAX_LEN, "%04d-%02d-%02d %02d:%02d:%02d.%09d",
              tmp->tm_year + 1900,
              tmp->tm_mon + 1,
@@ -780,36 +800,57 @@ col_set_utc_date_time(const frame_data *fd, column_info *cinfo, const int col)
 }
 
 static void
-set_time_seconds(const nstime_t *ts, gchar *buf)
+set_time_seconds(const frame_data *fd, const nstime_t *ts, gchar *buf)
 {
-  switch(timestamp_get_precision()) {
-      case TS_PREC_FIXED_SEC:
-      case TS_PREC_AUTO_SEC:
+  int tsprecision;
+
+  switch (timestamp_get_precision()) {
+  case TS_PREC_FIXED_SEC:
+      tsprecision = WTAP_TSPREC_SEC;
+      break;
+  case TS_PREC_FIXED_DSEC:
+      tsprecision = WTAP_TSPREC_DSEC;
+      break;
+  case TS_PREC_FIXED_CSEC:
+      tsprecision = WTAP_TSPREC_CSEC;
+      break;
+  case TS_PREC_FIXED_MSEC:
+      tsprecision = WTAP_TSPREC_MSEC;
+      break;
+  case TS_PREC_FIXED_USEC:
+      tsprecision = WTAP_TSPREC_USEC;
+      break;
+  case TS_PREC_FIXED_NSEC:
+      tsprecision = WTAP_TSPREC_NSEC;
+      break;
+  case TS_PREC_AUTO:
+      tsprecision = fd->tsprec;
+      break;
+  default:
+      g_assert_not_reached();
+  }
+  switch(tsprecision) {
+      case WTAP_TSPREC_SEC:
           display_signed_time(buf, COL_MAX_LEN,
             (gint32) ts->secs, ts->nsecs / 1000000000, TO_STR_TIME_RES_T_SECS);
           break;
-      case TS_PREC_FIXED_DSEC:
-      case TS_PREC_AUTO_DSEC:
+      case WTAP_TSPREC_DSEC:
           display_signed_time(buf, COL_MAX_LEN,
             (gint32) ts->secs, ts->nsecs / 100000000, TO_STR_TIME_RES_T_DSECS);
           break;
-      case TS_PREC_FIXED_CSEC:
-      case TS_PREC_AUTO_CSEC:
+      case WTAP_TSPREC_CSEC:
           display_signed_time(buf, COL_MAX_LEN,
             (gint32) ts->secs, ts->nsecs / 10000000, TO_STR_TIME_RES_T_CSECS);
           break;
-      case TS_PREC_FIXED_MSEC:
-      case TS_PREC_AUTO_MSEC:
+      case WTAP_TSPREC_MSEC:
           display_signed_time(buf, COL_MAX_LEN,
             (gint32) ts->secs, ts->nsecs / 1000000, TO_STR_TIME_RES_T_MSECS);
           break;
-      case TS_PREC_FIXED_USEC:
-      case TS_PREC_AUTO_USEC:
+      case WTAP_TSPREC_USEC:
           display_signed_time(buf, COL_MAX_LEN,
             (gint32) ts->secs, ts->nsecs / 1000, TO_STR_TIME_RES_T_USECS);
           break;
-      case TS_PREC_FIXED_NSEC:
-      case TS_PREC_AUTO_NSEC:
+      case WTAP_TSPREC_NSEC:
           display_signed_time(buf, COL_MAX_LEN,
             (gint32) ts->secs, ts->nsecs, TO_STR_TIME_RES_T_NSECS);
           break;
@@ -819,11 +860,12 @@ set_time_seconds(const nstime_t *ts, gchar *buf)
 }
 
 static void
-set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
+set_time_hour_min_sec(const frame_data *fd, const nstime_t *ts, gchar *buf)
 {
   time_t secs = ts->secs;
   long nsecs = (long) ts->nsecs;
   gboolean negative = FALSE;
+  int tsprecision;
 
   if (secs < 0) {
     secs = -secs;
@@ -834,9 +876,33 @@ set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
     negative = TRUE;
   }
 
-  switch(timestamp_get_precision()) {
+  switch (timestamp_get_precision()) {
   case TS_PREC_FIXED_SEC:
-  case TS_PREC_AUTO_SEC:
+      tsprecision = WTAP_TSPREC_SEC;
+      break;
+  case TS_PREC_FIXED_DSEC:
+      tsprecision = WTAP_TSPREC_DSEC;
+      break;
+  case TS_PREC_FIXED_CSEC:
+      tsprecision = WTAP_TSPREC_CSEC;
+      break;
+  case TS_PREC_FIXED_MSEC:
+      tsprecision = WTAP_TSPREC_MSEC;
+      break;
+  case TS_PREC_FIXED_USEC:
+      tsprecision = WTAP_TSPREC_USEC;
+      break;
+  case TS_PREC_FIXED_NSEC:
+      tsprecision = WTAP_TSPREC_NSEC;
+      break;
+  case TS_PREC_AUTO:
+      tsprecision = fd->tsprec;
+      break;
+  default:
+      g_assert_not_reached();
+  }
+  switch(tsprecision) {
+  case WTAP_TSPREC_SEC:
     if (secs >= (60*60)) {
       g_snprintf(buf, COL_MAX_LEN, "%s%dh %2dm %2ds",
 		 negative ? "- " : "",
@@ -854,8 +920,7 @@ set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
 		 (gint32) secs);
     }
     break;
-  case TS_PREC_FIXED_DSEC:
-  case TS_PREC_AUTO_DSEC:
+  case WTAP_TSPREC_DSEC:
     if (secs >= (60*60)) {
       g_snprintf(buf, COL_MAX_LEN, "%s%dh %2dm %2d.%01lds",
 		 negative ? "- " : "",
@@ -876,8 +941,7 @@ set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
 		 nsecs / 100000000);
     }
     break;
-  case TS_PREC_FIXED_CSEC:
-  case TS_PREC_AUTO_CSEC:
+  case WTAP_TSPREC_CSEC:
     if (secs >= (60*60)) {
       g_snprintf(buf, COL_MAX_LEN, "%s%dh %2dm %2d.%02lds",
 		 negative ? "- " : "",
@@ -898,8 +962,7 @@ set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
 		 nsecs / 10000000);
     }
     break;
-  case TS_PREC_FIXED_MSEC:
-  case TS_PREC_AUTO_MSEC:
+  case WTAP_TSPREC_MSEC:
     if (secs >= (60*60)) {
       g_snprintf(buf, COL_MAX_LEN, "%s%dh %2dm %2d.%03lds",
 		 negative ? "- " : "",
@@ -920,8 +983,7 @@ set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
 		 nsecs / 1000000);
     }
     break;
-  case TS_PREC_FIXED_USEC:
-  case TS_PREC_AUTO_USEC:
+  case WTAP_TSPREC_USEC:
     if (secs >= (60*60)) {
       g_snprintf(buf, COL_MAX_LEN, "%s%dh %2dm %2d.%06lds",
 		 negative ? "- " : "",
@@ -942,8 +1004,7 @@ set_time_hour_min_sec(const nstime_t *ts, gchar *buf)
 		 nsecs / 1000);
     }
     break;
-  case TS_PREC_FIXED_NSEC:
-  case TS_PREC_AUTO_NSEC:
+  case WTAP_TSPREC_NSEC:
     if (secs >= (60*60)) {
       g_snprintf(buf, COL_MAX_LEN, "%s%dh %2dm %2d.%09lds",
 		 negative ? "- " : "",
@@ -978,14 +1039,14 @@ col_set_rel_time(const frame_data *fd, column_info *cinfo, const int col)
   }
   switch (timestamp_get_seconds_type()) {
   case TS_SECONDS_DEFAULT:
-    set_time_seconds(&fd->rel_ts, cinfo->col_buf[col]);
+    set_time_seconds(fd, &fd->rel_ts, cinfo->col_buf[col]);
     cinfo->col_expr.col_expr[col] = "frame.time_relative";
     g_strlcpy(cinfo->col_expr.col_expr_val[col],cinfo->col_buf[col],COL_MAX_LEN);
     break;
   case TS_SECONDS_HOUR_MIN_SEC:
-    set_time_hour_min_sec(&fd->rel_ts, cinfo->col_buf[col]);
+    set_time_hour_min_sec(fd, &fd->rel_ts, cinfo->col_buf[col]);
     cinfo->col_expr.col_expr[col] = "frame.time_relative";
-    set_time_seconds(&fd->rel_ts, cinfo->col_expr.col_expr_val[col]);
+    set_time_seconds(fd, &fd->rel_ts, cinfo->col_expr.col_expr_val[col]);
     break;
   default:
     g_assert_not_reached();
@@ -1002,14 +1063,14 @@ col_set_delta_time(const frame_data *fd, column_info *cinfo, const int col)
 
   switch (timestamp_get_seconds_type()) {
   case TS_SECONDS_DEFAULT:
-    set_time_seconds(&del_cap_ts, cinfo->col_buf[col]);
+    set_time_seconds(fd, &del_cap_ts, cinfo->col_buf[col]);
     cinfo->col_expr.col_expr[col] = "frame.time_delta";
     g_strlcpy(cinfo->col_expr.col_expr_val[col],cinfo->col_buf[col],COL_MAX_LEN);
     break;
   case TS_SECONDS_HOUR_MIN_SEC:
-    set_time_hour_min_sec(&del_cap_ts, cinfo->col_buf[col]);
+    set_time_hour_min_sec(fd, &del_cap_ts, cinfo->col_buf[col]);
     cinfo->col_expr.col_expr[col] = "frame.time_delta";
-    set_time_seconds(&del_cap_ts, cinfo->col_expr.col_expr_val[col]);
+    set_time_seconds(fd, &del_cap_ts, cinfo->col_expr.col_expr_val[col]);
     break;
   default:
     g_assert_not_reached();
@@ -1032,14 +1093,14 @@ col_set_delta_time_dis(const frame_data *fd, column_info *cinfo, const int col)
 
   switch (timestamp_get_seconds_type()) {
   case TS_SECONDS_DEFAULT:
-    set_time_seconds(&del_dis_ts, cinfo->col_buf[col]);
+    set_time_seconds(fd, &del_dis_ts, cinfo->col_buf[col]);
     cinfo->col_expr.col_expr[col] = "frame.time_delta_displayed";
     g_strlcpy(cinfo->col_expr.col_expr_val[col],cinfo->col_buf[col],COL_MAX_LEN);
     break;
   case TS_SECONDS_HOUR_MIN_SEC:
-    set_time_hour_min_sec(&del_dis_ts, cinfo->col_buf[col]);
+    set_time_hour_min_sec(fd, &del_dis_ts, cinfo->col_buf[col]);
     cinfo->col_expr.col_expr[col] = "frame.time_delta_displayed";
-    set_time_seconds(&del_dis_ts, cinfo->col_expr.col_expr_val[col]);
+    set_time_seconds(fd, &del_dis_ts, cinfo->col_expr.col_expr_val[col]);
     break;
   default:
     g_assert_not_reached();
@@ -1053,6 +1114,7 @@ set_abs_time(const frame_data *fd, gchar *buf, gboolean local)
 {
   struct tm *tmp;
   time_t then;
+  int tsprecision;
 
   if (fd->flags.has_ts) {
     then = fd->abs_ts.secs;
@@ -1063,48 +1125,67 @@ set_abs_time(const frame_data *fd, gchar *buf, gboolean local)
   } else
     tmp = NULL;
   if (tmp != NULL) {
-      switch(timestamp_get_precision()) {
+      switch (timestamp_get_precision()) {
       case TS_PREC_FIXED_SEC:
-      case TS_PREC_AUTO_SEC:
+          tsprecision = WTAP_TSPREC_SEC;
+          break;
+      case TS_PREC_FIXED_DSEC:
+          tsprecision = WTAP_TSPREC_DSEC;
+          break;
+      case TS_PREC_FIXED_CSEC:
+          tsprecision = WTAP_TSPREC_CSEC;
+          break;
+      case TS_PREC_FIXED_MSEC:
+          tsprecision = WTAP_TSPREC_MSEC;
+          break;
+      case TS_PREC_FIXED_USEC:
+          tsprecision = WTAP_TSPREC_USEC;
+          break;
+      case TS_PREC_FIXED_NSEC:
+          tsprecision = WTAP_TSPREC_NSEC;
+          break;
+      case TS_PREC_AUTO:
+          tsprecision = fd->tsprec;
+          break;
+      default:
+          g_assert_not_reached();
+      }
+      switch(tsprecision) {
+      case WTAP_TSPREC_SEC:
           g_snprintf(buf, COL_MAX_LEN,"%02d:%02d:%02d",
              tmp->tm_hour,
              tmp->tm_min,
              tmp->tm_sec);
           break;
-      case TS_PREC_FIXED_DSEC:
-      case TS_PREC_AUTO_DSEC:
+      case WTAP_TSPREC_DSEC:
           g_snprintf(buf, COL_MAX_LEN,"%02d:%02d:%02d.%01d",
              tmp->tm_hour,
              tmp->tm_min,
              tmp->tm_sec,
              fd->abs_ts.nsecs / 100000000);
           break;
-      case TS_PREC_FIXED_CSEC:
-      case TS_PREC_AUTO_CSEC:
+      case WTAP_TSPREC_CSEC:
           g_snprintf(buf, COL_MAX_LEN,"%02d:%02d:%02d.%02d",
              tmp->tm_hour,
              tmp->tm_min,
              tmp->tm_sec,
              fd->abs_ts.nsecs / 10000000);
           break;
-      case TS_PREC_FIXED_MSEC:
-      case TS_PREC_AUTO_MSEC:
+      case WTAP_TSPREC_MSEC:
           g_snprintf(buf, COL_MAX_LEN,"%02d:%02d:%02d.%03d",
              tmp->tm_hour,
              tmp->tm_min,
              tmp->tm_sec,
              fd->abs_ts.nsecs / 1000000);
           break;
-      case TS_PREC_FIXED_USEC:
-      case TS_PREC_AUTO_USEC:
+      case WTAP_TSPREC_USEC:
           g_snprintf(buf, COL_MAX_LEN,"%02d:%02d:%02d.%06d",
              tmp->tm_hour,
              tmp->tm_min,
              tmp->tm_sec,
              fd->abs_ts.nsecs / 1000);
           break;
-      case TS_PREC_FIXED_NSEC:
-      case TS_PREC_AUTO_NSEC:
+      case WTAP_TSPREC_NSEC:
           g_snprintf(buf, COL_MAX_LEN, "%02d:%02d:%02d.%09d",
              tmp->tm_hour,
              tmp->tm_min,
@@ -1143,38 +1224,59 @@ col_set_utc_time(const frame_data *fd, column_info *cinfo, const int col)
 static gboolean
 set_epoch_time(const frame_data *fd, gchar *buf)
 {
+  int tsprecision;
+
   if (!fd->flags.has_ts) {
     buf[0] = '\0';
     return FALSE;
   }
-  switch(timestamp_get_precision()) {
-      case TS_PREC_FIXED_SEC:
-      case TS_PREC_AUTO_SEC:
+  switch (timestamp_get_precision()) {
+  case TS_PREC_FIXED_SEC:
+      tsprecision = WTAP_TSPREC_SEC;
+      break;
+  case TS_PREC_FIXED_DSEC:
+      tsprecision = WTAP_TSPREC_DSEC;
+      break;
+  case TS_PREC_FIXED_CSEC:
+      tsprecision = WTAP_TSPREC_CSEC;
+      break;
+  case TS_PREC_FIXED_MSEC:
+      tsprecision = WTAP_TSPREC_MSEC;
+      break;
+  case TS_PREC_FIXED_USEC:
+      tsprecision = WTAP_TSPREC_USEC;
+      break;
+  case TS_PREC_FIXED_NSEC:
+      tsprecision = WTAP_TSPREC_NSEC;
+      break;
+  case TS_PREC_AUTO:
+      tsprecision = fd->tsprec;
+      break;
+  default:
+      g_assert_not_reached();
+  }
+  switch(tsprecision) {
+      case WTAP_TSPREC_SEC:
           display_epoch_time(buf, COL_MAX_LEN,
             fd->abs_ts.secs, fd->abs_ts.nsecs / 1000000000, TO_STR_TIME_RES_T_SECS);
           break;
-      case TS_PREC_FIXED_DSEC:
-      case TS_PREC_AUTO_DSEC:
+      case WTAP_TSPREC_DSEC:
           display_epoch_time(buf, COL_MAX_LEN,
             fd->abs_ts.secs, fd->abs_ts.nsecs / 100000000, TO_STR_TIME_RES_T_DSECS);
           break;
-      case TS_PREC_FIXED_CSEC:
-      case TS_PREC_AUTO_CSEC:
+      case WTAP_TSPREC_CSEC:
           display_epoch_time(buf, COL_MAX_LEN,
             fd->abs_ts.secs, fd->abs_ts.nsecs / 10000000, TO_STR_TIME_RES_T_CSECS);
           break;
-      case TS_PREC_FIXED_MSEC:
-      case TS_PREC_AUTO_MSEC:
+      case WTAP_TSPREC_MSEC:
           display_epoch_time(buf, COL_MAX_LEN,
             fd->abs_ts.secs, fd->abs_ts.nsecs / 1000000, TO_STR_TIME_RES_T_MSECS);
           break;
-      case TS_PREC_FIXED_USEC:
-      case TS_PREC_AUTO_USEC:
+      case WTAP_TSPREC_USEC:
           display_epoch_time(buf, COL_MAX_LEN,
             fd->abs_ts.secs, fd->abs_ts.nsecs / 1000, TO_STR_TIME_RES_T_USECS);
           break;
-      case TS_PREC_FIXED_NSEC:
-      case TS_PREC_AUTO_NSEC:
+      case WTAP_TSPREC_NSEC:
           display_epoch_time(buf, COL_MAX_LEN,
             fd->abs_ts.secs, fd->abs_ts.nsecs, TO_STR_TIME_RES_T_NSECS);
           break;
@@ -1211,10 +1313,10 @@ set_fd_time(frame_data *fd, gchar *buf)
       if (fd->flags.has_ts) {
         switch (timestamp_get_seconds_type()) {
         case TS_SECONDS_DEFAULT:
-          set_time_seconds(&fd->rel_ts, buf);
+          set_time_seconds(fd, &fd->rel_ts, buf);
           break;
         case TS_SECONDS_HOUR_MIN_SEC:
-          set_time_seconds(&fd->rel_ts, buf);
+          set_time_seconds(fd, &fd->rel_ts, buf);
           break;
         default:
           g_assert_not_reached();
@@ -1232,10 +1334,10 @@ set_fd_time(frame_data *fd, gchar *buf)
 
         switch (timestamp_get_seconds_type()) {
         case TS_SECONDS_DEFAULT:
-          set_time_seconds(&del_cap_ts, buf);
+          set_time_seconds(fd, &del_cap_ts, buf);
           break;
         case TS_SECONDS_HOUR_MIN_SEC:
-          set_time_hour_min_sec(&del_cap_ts, buf);
+          set_time_hour_min_sec(fd, &del_cap_ts, buf);
           break;
         default:
           g_assert_not_reached();
@@ -1253,10 +1355,10 @@ set_fd_time(frame_data *fd, gchar *buf)
 
         switch (timestamp_get_seconds_type()) {
         case TS_SECONDS_DEFAULT:
-          set_time_seconds(&del_dis_ts, buf);
+          set_time_seconds(fd, &del_dis_ts, buf);
           break;
         case TS_SECONDS_HOUR_MIN_SEC:
-          set_time_hour_min_sec(&del_dis_ts, buf);
+          set_time_hour_min_sec(fd, &del_dis_ts, buf);
           break;
         default:
           g_assert_not_reached();
@@ -1400,38 +1502,33 @@ col_set_time(column_info *cinfo, const gint el, const nstime_t *ts, const char *
   for (col = cinfo->col_first[el]; col <= cinfo->col_last[el]; col++) {
     if (cinfo->fmt_matx[col][el]) {
       switch(timestamp_get_precision()) {
-    case TS_PREC_FIXED_SEC:
-    case TS_PREC_AUTO_SEC:
-      display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
-        (gint32) ts->secs, ts->nsecs / 1000000000, TO_STR_TIME_RES_T_SECS);
-      break;
-    case TS_PREC_FIXED_DSEC:
-    case TS_PREC_AUTO_DSEC:
-      display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
-        (gint32) ts->secs, ts->nsecs / 100000000, TO_STR_TIME_RES_T_DSECS);
-      break;
-    case TS_PREC_FIXED_CSEC:
-    case TS_PREC_AUTO_CSEC:
-      display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
-        (gint32) ts->secs, ts->nsecs / 10000000, TO_STR_TIME_RES_T_CSECS);
-      break;
-    case TS_PREC_FIXED_MSEC:
-    case TS_PREC_AUTO_MSEC:
-      display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
-        (gint32) ts->secs, ts->nsecs / 1000000, TO_STR_TIME_RES_T_MSECS);
-      break;
-    case TS_PREC_FIXED_USEC:
-    case TS_PREC_AUTO_USEC:
-      display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
-        (gint32) ts->secs, ts->nsecs / 1000, TO_STR_TIME_RES_T_USECS);
-      break;
-    case TS_PREC_FIXED_NSEC:
-    case TS_PREC_AUTO_NSEC:
-      display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
-        (gint32) ts->secs, ts->nsecs, TO_STR_TIME_RES_T_NSECS);
-      break;
-    default:
-      g_assert_not_reached();
+      case TS_PREC_FIXED_SEC:
+          display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
+            (gint32) ts->secs, ts->nsecs / 1000000000, TO_STR_TIME_RES_T_SECS);
+          break;
+      case TS_PREC_FIXED_DSEC:
+          display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
+            (gint32) ts->secs, ts->nsecs / 100000000, TO_STR_TIME_RES_T_DSECS);
+          break;
+      case TS_PREC_FIXED_CSEC:
+          display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
+            (gint32) ts->secs, ts->nsecs / 10000000, TO_STR_TIME_RES_T_CSECS);
+          break;
+      case TS_PREC_FIXED_MSEC:
+          display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
+            (gint32) ts->secs, ts->nsecs / 1000000, TO_STR_TIME_RES_T_MSECS);
+          break;
+      case TS_PREC_FIXED_USEC:
+          display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
+            (gint32) ts->secs, ts->nsecs / 1000, TO_STR_TIME_RES_T_USECS);
+          break;
+      case TS_PREC_FIXED_NSEC:
+      case TS_PREC_AUTO:    /* default to maximum */
+          display_signed_time(cinfo->col_buf[col], COL_MAX_LEN,
+            (gint32) ts->secs, ts->nsecs, TO_STR_TIME_RES_T_NSECS);
+          break;
+      default:
+          g_assert_not_reached();
       }
       cinfo->col_data[col] = cinfo->col_buf[col];
       cinfo->col_expr.col_expr[col] = fieldname;
diff --git a/epan/column.c b/epan/column.c
index 231f1c5..43da75f 100644
--- a/epan/column.c
+++ b/epan/column.c
@@ -254,28 +254,23 @@ get_timestamp_column_longest_string(const gint type, const gint precision)
     case(TS_ABSOLUTE_WITH_DATE):
     case(TS_UTC_WITH_DATE):
         switch(precision) {
-            case(TS_PREC_AUTO_SEC):
             case(TS_PREC_FIXED_SEC):
                 return "0000-00-00 00:00:00";
                 break;
-            case(TS_PREC_AUTO_DSEC):
             case(TS_PREC_FIXED_DSEC):
                 return "0000-00-00 00:00:00.0";
                 break;
-            case(TS_PREC_AUTO_CSEC):
             case(TS_PREC_FIXED_CSEC):
                 return "0000-00-00 00:00:00.00";
                 break;
-            case(TS_PREC_AUTO_MSEC):
             case(TS_PREC_FIXED_MSEC):
                 return "0000-00-00 00:00:00.000";
                 break;
-            case(TS_PREC_AUTO_USEC):
             case(TS_PREC_FIXED_USEC):
                 return "0000-00-00 00:00:00.000000";
                 break;
-            case(TS_PREC_AUTO_NSEC):
             case(TS_PREC_FIXED_NSEC):
+            case(TS_PREC_AUTO):    /* Leave enough room for the maximum */
                 return "0000-00-00 00:00:00.000000000";
                 break;
             default:
@@ -285,28 +280,23 @@ get_timestamp_column_longest_string(const gint type, const gint precision)
     case(TS_ABSOLUTE):
     case(TS_UTC):
         switch(precision) {
-            case(TS_PREC_AUTO_SEC):
             case(TS_PREC_FIXED_SEC):
                 return "00:00:00";
                 break;
-            case(TS_PREC_AUTO_DSEC):
             case(TS_PREC_FIXED_DSEC):
                 return "00:00:00.0";
                 break;
-            case(TS_PREC_AUTO_CSEC):
             case(TS_PREC_FIXED_CSEC):
                 return "00:00:00.00";
                 break;
-            case(TS_PREC_AUTO_MSEC):
             case(TS_PREC_FIXED_MSEC):
                 return "00:00:00.000";
                 break;
-            case(TS_PREC_AUTO_USEC):
             case(TS_PREC_FIXED_USEC):
                 return "00:00:00.000000";
                 break;
-            case(TS_PREC_AUTO_NSEC):
             case(TS_PREC_FIXED_NSEC):
+            case(TS_PREC_AUTO):    /* Leave enough room for the maximum */
                 return "00:00:00.000000000";
                 break;
             default:
@@ -317,28 +307,23 @@ get_timestamp_column_longest_string(const gint type, const gint precision)
     case(TS_DELTA):
     case(TS_DELTA_DIS):
         switch(precision) {
-            case(TS_PREC_AUTO_SEC):
             case(TS_PREC_FIXED_SEC):
                 return "0000";
                 break;
-            case(TS_PREC_AUTO_DSEC):
             case(TS_PREC_FIXED_DSEC):
                 return "0000.0";
                 break;
-            case(TS_PREC_AUTO_CSEC):
             case(TS_PREC_FIXED_CSEC):
                 return "0000.00";
                 break;
-            case(TS_PREC_AUTO_MSEC):
             case(TS_PREC_FIXED_MSEC):
                 return "0000.000";
                 break;
-            case(TS_PREC_AUTO_USEC):
             case(TS_PREC_FIXED_USEC):
                 return "0000.000000";
                 break;
-            case(TS_PREC_AUTO_NSEC):
             case(TS_PREC_FIXED_NSEC):
+            case(TS_PREC_AUTO):    /* Leave enough room for the maximum */
                 return "0000.000000000";
                 break;
             default:
@@ -348,28 +333,23 @@ get_timestamp_column_longest_string(const gint type, const gint precision)
     case(TS_EPOCH):
         /* This is enough to represent 2^63 (signed 64-bit integer) + fractions */
         switch(precision) {
-            case(TS_PREC_AUTO_SEC):
             case(TS_PREC_FIXED_SEC):
                 return "0000000000000000000";
                 break;
-            case(TS_PREC_AUTO_DSEC):
             case(TS_PREC_FIXED_DSEC):
                 return "0000000000000000000.0";
                 break;
-            case(TS_PREC_AUTO_CSEC):
             case(TS_PREC_FIXED_CSEC):
                 return "0000000000000000000.00";
                 break;
-            case(TS_PREC_AUTO_MSEC):
             case(TS_PREC_FIXED_MSEC):
                 return "0000000000000000000.000";
                 break;
-            case(TS_PREC_AUTO_USEC):
             case(TS_PREC_FIXED_USEC):
                 return "0000000000000000000.000000";
                 break;
-            case(TS_PREC_AUTO_NSEC):
             case(TS_PREC_FIXED_NSEC):
+            case(TS_PREC_AUTO):    /* Leave enough room for the maximum */
                 return "0000000000000000000.000000000";
                 break;
             default:
diff --git a/epan/frame_data.c b/epan/frame_data.c
index 63d9805..79b435e 100644
--- a/epan/frame_data.c
+++ b/epan/frame_data.c
@@ -269,6 +269,7 @@ frame_data_init(frame_data *fdata, guint32 num,
   fdata->flags.ignored = 0;
   fdata->flags.has_ts = (phdr->presence_flags & WTAP_HAS_TS) ? 1 : 0;
   fdata->flags.has_if_id = (phdr->presence_flags & WTAP_HAS_INTERFACE_ID) ? 1 : 0;
+  fdata->tsprec = (guint16)phdr->pkt_tsprec;
   fdata->flags.has_pack_flags = (phdr->presence_flags & WTAP_HAS_PACK_FLAGS) ? 1 : 0;
   fdata->color_filter = NULL;
   fdata->abs_ts.secs = phdr->ts.secs;
diff --git a/epan/frame_data.h b/epan/frame_data.h
index 580d238..2a73cdf 100644
--- a/epan/frame_data.h
+++ b/epan/frame_data.h
@@ -69,6 +69,7 @@ typedef struct _frame_data {
     unsigned int has_if_id      : 1; /**< 1 = has interface ID, 0 = no interface ID */
     unsigned int has_pack_flags : 1; /**< 1 = has packet flags, 0 = no packet flags */
   } flags;
+  gint16       tsprec;       /**< Time stamp precision */
 
   const void *color_filter;  /**< Per-packet matching color_filter_t object */
 
diff --git a/epan/timestamp.c b/epan/timestamp.c
index 155d8bb..65aa41c 100644
--- a/epan/timestamp.c
+++ b/epan/timestamp.c
@@ -30,7 +30,7 @@
  * and distinguish it from a command line value */
 static ts_type timestamp_type = TS_NOT_SET;
 
-static int timestamp_precision = TS_PREC_AUTO_USEC;
+static int timestamp_precision = TS_PREC_AUTO;
 
 static ts_seconds_type timestamp_seconds_type = TS_SECONDS_NOT_SET;
 
diff --git a/epan/timestamp.h b/epan/timestamp.h
index 0992b3e..3881696 100644
--- a/epan/timestamp.h
+++ b/epan/timestamp.h
@@ -52,19 +52,13 @@ typedef enum {
 } ts_type;
 
 typedef enum {
-	TS_PREC_AUTO,		/* recent */
-	TS_PREC_FIXED_SEC,	/* recent and internal */
-	TS_PREC_FIXED_DSEC,	/* recent and internal */
-	TS_PREC_FIXED_CSEC,	/* recent and internal */
-	TS_PREC_FIXED_MSEC,	/* recent and internal */
-	TS_PREC_FIXED_USEC,	/* recent and internal */
-	TS_PREC_FIXED_NSEC,	/* recent and internal */
-	TS_PREC_AUTO_SEC,	/* internal */
-	TS_PREC_AUTO_DSEC,	/* internal */
-	TS_PREC_AUTO_CSEC,	/* internal */
-	TS_PREC_AUTO_MSEC,	/* internal */
-	TS_PREC_AUTO_USEC,	/* internal */
-	TS_PREC_AUTO_NSEC	/* internal */
+	TS_PREC_AUTO,
+	TS_PREC_FIXED_SEC,
+	TS_PREC_FIXED_DSEC,
+	TS_PREC_FIXED_CSEC,
+	TS_PREC_FIXED_MSEC,
+	TS_PREC_FIXED_USEC,
+	TS_PREC_FIXED_NSEC,
 } ts_precision;
 
 typedef enum {
diff --git a/epan/wslua/make-init-lua.pl b/epan/wslua/make-init-lua.pl
index 878faf5..e9f186d 100755
--- a/epan/wslua/make-init-lua.pl
+++ b/epan/wslua/make-init-lua.pl
@@ -33,6 +33,7 @@ my $WSROOT = shift;
 die "'$WSROOT' is not a directory" unless -d $WSROOT;
 
 my $wtap_encaps_table = '';
+my $wtap_tsprecs_table = '';
 my $wtap_filetypes_table = '';
 my $ft_types_table = '';
 my $bases_table = '';
@@ -42,6 +43,7 @@ my $menu_groups = '';
 
 my %replacements = %{{
     WTAP_ENCAPS => \$wtap_encaps_table,
+    WTAP_TSPRECS => \$wtap_tsprecs_table,
     WTAP_FILETYPES => \$wtap_filetypes_table,
     FT_TYPES => \$ft_types_table,
     BASES => \$bases_table,
@@ -69,6 +71,7 @@ close TEMPLATE;
 #
 
 $wtap_encaps_table = "-- Wiretap encapsulations XXX\nwtap_encaps = {\n";
+$wtap_tsprecs_table = "-- Wiretap timestamp precision types\nwtap_tsprecs = {\n";
 $wtap_filetypes_table = "-- Wiretap file types\nwtap_filetypes = {\n";
 
 open WTAP_H, "< $WSROOT/wiretap/wtap.h" or die "cannot open '$WSROOT/wiretap/wtap.h':  $!";
@@ -81,10 +84,17 @@ while(<WTAP_H>) {
     if ( /^#define WTAP_FILE_([A-Z0-9_]+)\s+(\d+)/ ) {
         $wtap_filetypes_table .= "\t[\"$1\"] = $2,\n";
     }
+
+    if ( /^#define WTAP_TSPREC_([A-Z0-9_]+)\s+(\d+)/ ) {
+        $wtap_tsprecs_table .= "\t[\"$1\"] = $2,\n";
+        # for backwards compatibility we need to add them to the filetypes table too
+        $wtap_filetypes_table .= "\t[\"TSPREC_$1\"] = $2,\n";
+    }
 }
 
 $wtap_encaps_table =~ s/,\n$/\n}\nwtap = wtap_encaps -- for bw compatibility\n/msi;
 $wtap_filetypes_table =~ s/,\n$/\n}\n/msi;
+$wtap_tsprecs_table =~ s/,\n$/\n}\n/msi;
 
 #
 # Extract values from epan/ftypes/ftypes.h:
diff --git a/epan/wslua/template-init.lua b/epan/wslua/template-init.lua
index 2538c4c..31f298e 100644
--- a/epan/wslua/template-init.lua
+++ b/epan/wslua/template-init.lua
@@ -66,6 +66,8 @@ end
 
 -- %WTAP_ENCAPS%
 
+-- %WTAP_TSPRECS%
+
 -- %WTAP_FILETYPES%
 
 -- %FT_TYPES%
diff --git a/file.c b/file.c
index 5059e0b..6db3c68 100644
--- a/file.c
+++ b/file.c
@@ -222,7 +222,6 @@ void
 cf_timestamp_auto_precision(capture_file *cf)
 {
   int i;
-  int prec = timestamp_get_precision();
 
 
   /* don't try to get the file's precision if none is opened */
@@ -230,38 +229,6 @@ cf_timestamp_auto_precision(capture_file *cf)
     return;
   }
 
-  /* if we are in auto mode, set precision of current file */
-  if (prec == TS_PREC_AUTO ||
-     prec == TS_PREC_AUTO_SEC ||
-     prec == TS_PREC_AUTO_DSEC ||
-     prec == TS_PREC_AUTO_CSEC ||
-     prec == TS_PREC_AUTO_MSEC ||
-     prec == TS_PREC_AUTO_USEC ||
-     prec == TS_PREC_AUTO_NSEC)
-  {
-    switch(wtap_file_tsprecision(cf->wth)) {
-    case(WTAP_FILE_TSPREC_SEC):
-      timestamp_set_precision(TS_PREC_AUTO_SEC);
-      break;
-    case(WTAP_FILE_TSPREC_DSEC):
-      timestamp_set_precision(TS_PREC_AUTO_DSEC);
-      break;
-    case(WTAP_FILE_TSPREC_CSEC):
-      timestamp_set_precision(TS_PREC_AUTO_CSEC);
-      break;
-    case(WTAP_FILE_TSPREC_MSEC):
-      timestamp_set_precision(TS_PREC_AUTO_MSEC);
-      break;
-    case(WTAP_FILE_TSPREC_USEC):
-      timestamp_set_precision(TS_PREC_AUTO_USEC);
-      break;
-    case(WTAP_FILE_TSPREC_NSEC):
-      timestamp_set_precision(TS_PREC_AUTO_NSEC);
-      break;
-    default:
-      g_assert_not_reached();
-    }
-  }
   /* Set the column widths of those columns that show the time in
      "command-line-specified" format. */
   for (i = 0; i < cf->cinfo.num_cols; i++) {
diff --git a/rawshark.c b/rawshark.c
index dbb9f42..1d2ff97 100644
--- a/rawshark.c
+++ b/rawshark.c
@@ -832,35 +832,6 @@ main(int argc, char *argv[])
             }
         }
 
-        /* Set timestamp precision; there should arguably be a command-line
-           option to let the user set this. */
-#if 0
-        switch(wtap_file_tsprecision(cfile.wth)) {
-            case(WTAP_FILE_TSPREC_SEC):
-                timestamp_set_precision(TS_PREC_AUTO_SEC);
-                break;
-            case(WTAP_FILE_TSPREC_DSEC):
-                timestamp_set_precision(TS_PREC_AUTO_DSEC);
-                break;
-            case(WTAP_FILE_TSPREC_CSEC):
-                timestamp_set_precision(TS_PREC_AUTO_CSEC);
-                break;
-            case(WTAP_FILE_TSPREC_MSEC):
-                timestamp_set_precision(TS_PREC_AUTO_MSEC);
-                break;
-            case(WTAP_FILE_TSPREC_USEC):
-                timestamp_set_precision(TS_PREC_AUTO_USEC);
-                break;
-            case(WTAP_FILE_TSPREC_NSEC):
-                timestamp_set_precision(TS_PREC_AUTO_NSEC);
-                break;
-            default:
-                g_assert_not_reached();
-        }
-#else
-        timestamp_set_precision(TS_PREC_AUTO_USEC);
-#endif
-
         /* Process the packets in the file */
         err = load_cap_file(&cfile);
 
diff --git a/tshark.c b/tshark.c
index 98b95bf..8c8de07 100644
--- a/tshark.c
+++ b/tshark.c
@@ -1903,31 +1903,6 @@ main(int argc, char *argv[])
       return 2;
     }
 
-    /* Set timestamp precision; there should arguably be a command-line
-       option to let the user set this. */
-    switch(wtap_file_tsprecision(cfile.wth)) {
-    case(WTAP_FILE_TSPREC_SEC):
-      timestamp_set_precision(TS_PREC_AUTO_SEC);
-      break;
-    case(WTAP_FILE_TSPREC_DSEC):
-      timestamp_set_precision(TS_PREC_AUTO_DSEC);
-      break;
-    case(WTAP_FILE_TSPREC_CSEC):
-      timestamp_set_precision(TS_PREC_AUTO_CSEC);
-      break;
-    case(WTAP_FILE_TSPREC_MSEC):
-      timestamp_set_precision(TS_PREC_AUTO_MSEC);
-      break;
-    case(WTAP_FILE_TSPREC_USEC):
-      timestamp_set_precision(TS_PREC_AUTO_USEC);
-      break;
-    case(WTAP_FILE_TSPREC_NSEC):
-      timestamp_set_precision(TS_PREC_AUTO_NSEC);
-      break;
-    default:
-      g_assert_not_reached();
-    }
-
     /* Process the packets in the file */
     TRY {
 #ifdef HAVE_LIBPCAP
@@ -2030,9 +2005,6 @@ main(int argc, char *argv[])
       }
     }
 
-    /* For now, assume libpcap gives microsecond precision. */
-    timestamp_set_precision(TS_PREC_AUTO_USEC);
-
     /*
      * XXX - this returns FALSE if an error occurred, but it also
      * returns FALSE if the capture stops because a time limit
diff --git a/ui/cli/tap-comparestat.c b/ui/cli/tap-comparestat.c
index 6f55926..d449f32 100644
--- a/ui/cli/tap-comparestat.c
+++ b/ui/cli/tap-comparestat.c
@@ -545,8 +545,6 @@ comparestat_init(const char *optarg, void* userdata _U_)
 	cs->zebra_time.secs=0;
 	cs->zebra_time.nsecs=1;
 	cs->nr_tree=se_tree_create(EMEM_TREE_TYPE_RED_BLACK, "nr_tree");
-	/* microsecond precision */
-	timestamp_set_precision(TS_PREC_AUTO_NSEC);
 
 	if(filter){
 		cs->filter=g_strdup(filter);
diff --git a/ui/gtk/compare_stat.c b/ui/gtk/compare_stat.c
index e07ee96..b8ad2b2 100644
--- a/ui/gtk/compare_stat.c
+++ b/ui/gtk/compare_stat.c
@@ -584,8 +584,6 @@ comparestat_draw(void *arg)
 	second_file_amount=cs->second_file_amount;
 	/* reset after numbering */
 	cs->nr_tree=se_tree_create(EMEM_TREE_TYPE_RED_BLACK, "nr_tree");
-	/* microsecond precision for Info column*/
-	timestamp_set_precision(TS_PREC_AUTO_NSEC);
 	/* reset ordering */
 	nstime_set_unset(&cs->current_time);
 
@@ -738,8 +736,6 @@ gtk_comparestat_init(const char *opt_arg, void* userdata _U_)
 	cs->zebra_time.secs=0;
 	cs->zebra_time.nsecs=1;
 	cs->nr_tree=se_tree_create(EMEM_TREE_TYPE_RED_BLACK, "nr_tree");
-	/* microsecond precision */
-	timestamp_set_precision(TS_PREC_AUTO_NSEC);
 
 	/* transient_for top_level */
 	cs->win=dlg_window_new("compare-stat");
diff --git a/ui/gtk/main_menubar.c b/ui/gtk/main_menubar.c
index 23ceff2..dd83125 100644
--- a/ui/gtk/main_menubar.c
+++ b/ui/gtk/main_menubar.c
@@ -635,11 +635,7 @@ timestamp_precision_new_cb (GtkRadioAction *action, GtkRadioAction *current _U_,
     value = gtk_radio_action_get_current_value (action);
     if (recent.gui_time_precision != value) {
         /* the actual precision will be set in packet_list_queue_draw() below */
-        if (value == TS_PREC_AUTO) {
-            timestamp_set_precision(TS_PREC_AUTO_SEC);
-        } else {
-            timestamp_set_precision(value);
-        }
+        timestamp_set_precision(value);
         recent.gui_time_precision  = value;
         /* This call adjusts column width */
         cf_timestamp_auto_precision(&cfile);
@@ -1818,7 +1814,7 @@ static const GtkRadioActionEntry main_menu_bar_radio_view_time_entries [] =
 static const GtkRadioActionEntry main_menu_bar_radio_view_time_fileformat_prec_entries [] =
 {
     /* name, stock id, label, accel, tooltip,  value */
-    { "/View/TimeDisplayFormat/FileFormatPrecision-Automatic",      NULL, "Automatic (File Format Precision)",  NULL, NULL, TS_PREC_AUTO },
+    { "/View/TimeDisplayFormat/FileFormatPrecision-Automatic",      NULL, "Automatic (use precision indicated in the file)",  NULL, NULL, TS_PREC_AUTO },
     { "/View/TimeDisplayFormat/FileFormatPrecision-Seconds",        NULL, "Seconds:   0",                       NULL, NULL, TS_PREC_FIXED_SEC },
     { "/View/TimeDisplayFormat/FileFormatPrecision-Deciseconds",    NULL, "Deciseconds:   0.1",                 NULL, NULL, TS_PREC_FIXED_DSEC },
     { "/View/TimeDisplayFormat/FileFormatPrecision-Centiseconds",   NULL, "Centiseconds:  0.12",                NULL, NULL, TS_PREC_FIXED_CSEC },
@@ -4634,8 +4630,8 @@ menu_recent_read_finished(void)
     cf_timestamp_auto_precision(&cfile);
     packet_list_queue_draw();
     /* the actual precision will be set in packet_list_queue_draw() below */
-    if (recent.gui_time_precision == TS_PREC_AUTO) {
-        timestamp_set_precision(TS_PREC_AUTO_SEC);
+    if (recent.gui_time_precision > TS_PREC_FIXED_NSEC) {
+        timestamp_set_precision(TS_PREC_AUTO);
     } else {
         timestamp_set_precision(recent.gui_time_precision);
     }
diff --git a/ui/qt/main.cpp b/ui/qt/main.cpp
index 12b0e81..3193702 100644
--- a/ui/qt/main.cpp
+++ b/ui/qt/main.cpp
@@ -856,7 +856,7 @@ int main(int argc, char *argv[])
 
     g_log(NULL, G_LOG_LEVEL_DEBUG, "FIX: timestamp types should be set elsewhere");
     timestamp_set_type(TS_RELATIVE);
-    timestamp_set_precision(TS_PREC_AUTO_USEC);
+    timestamp_set_precision(TS_PREC_AUTO);
     timestamp_set_seconds_type(TS_SECONDS_DEFAULT);
 
 /////////
diff --git a/wiretap/5views.c b/wiretap/5views.c
index e8dd0b8..c7a9078 100644
--- a/wiretap/5views.c
+++ b/wiretap/5views.c
@@ -191,7 +191,7 @@ int _5views_open(wtap *wth, int *err, gchar **err_info)
 	wth->subtype_seek_read = _5views_seek_read;
 	wth->file_encap = encap;
 	wth->snapshot_length = 0;	/* not available in header */
-	wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+	wth->file_tsprec = WTAP_TSPREC_NSEC;
 
 	return 1;
 }
diff --git a/wiretap/aethra.c b/wiretap/aethra.c
index d04bf8d..02d1b6c 100644
--- a/wiretap/aethra.c
+++ b/wiretap/aethra.c
@@ -178,7 +178,7 @@ int aethra_open(wtap *wth, int *err, gchar **err_info)
 	 */
 	wth->file_encap = WTAP_ENCAP_ISDN;
 	wth->snapshot_length = 0;	/* not available in header */
-	wth->tsprecision = WTAP_FILE_TSPREC_MSEC;
+	wth->file_tsprec = WTAP_TSPREC_MSEC;
 	return 1;
 }
 
diff --git a/wiretap/ascendtext.c b/wiretap/ascendtext.c
index d0b4e76..a05fe34 100644
--- a/wiretap/ascendtext.c
+++ b/wiretap/ascendtext.c
@@ -229,7 +229,7 @@ int ascend_open(wtap *wth, int *err, gchar **err_info)
   }
   ascend->inittime = statbuf.st_ctime;
   ascend->adjusted = 0;
-  wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+  wth->file_tsprec = WTAP_TSPREC_USEC;
 
   init_parse_ascend();
 
diff --git a/wiretap/ber.c b/wiretap/ber.c
index 990db1d..6904367 100644
--- a/wiretap/ber.c
+++ b/wiretap/ber.c
@@ -192,7 +192,7 @@ int ber_open(wtap *wth, int *err, gchar **err_info)
 
   wth->subtype_read = ber_read;
   wth->subtype_seek_read = ber_seek_read;
-  wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+  wth->file_tsprec = WTAP_TSPREC_SEC;
 
   return 1;
 }
diff --git a/wiretap/btsnoop.c b/wiretap/btsnoop.c
index 042cc8b..1a2e8ac 100644
--- a/wiretap/btsnoop.c
+++ b/wiretap/btsnoop.c
@@ -147,7 +147,7 @@ int btsnoop_open(wtap *wth, int *err, gchar **err_info)
 	wth->subtype_seek_read = btsnoop_seek_read;
 	wth->file_encap = file_encap;
 	wth->snapshot_length = 0;	/* not available in header */
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 	wth->file_type = WTAP_FILE_BTSNOOP;
 	return 1;
 }
@@ -443,7 +443,7 @@ gboolean btsnoop_dump_open_h1(wtap_dumper *wdh, int *err)
     switch (wdh->file_type) {
 
     case WTAP_FILE_BTSNOOP:
-        wdh->tsprecision = WTAP_FILE_TSPREC_USEC;
+        wdh->tsprecision = WTAP_TSPREC_USEC;
         break;
 
     default:
@@ -485,7 +485,7 @@ gboolean btsnoop_dump_open_h4(wtap_dumper *wdh, int *err)
     switch (wdh->file_type) {
 
     case WTAP_FILE_BTSNOOP:
-        wdh->tsprecision = WTAP_FILE_TSPREC_USEC;
+        wdh->tsprecision = WTAP_TSPREC_USEC;
         break;
 
     default:
diff --git a/wiretap/camins.c b/wiretap/camins.c
index 879b68d..3c7a608 100644
--- a/wiretap/camins.c
+++ b/wiretap/camins.c
@@ -372,7 +372,7 @@ int camins_open(wtap *wth, int *err, gchar **err_info _U_)
 
    wth->file_encap = WTAP_ENCAP_DVBCI;
    wth->snapshot_length = 0;
-   wth->tsprecision = WTAP_FILE_TSPREC_MSEC;
+   wth->file_tsprec = WTAP_TSPREC_MSEC;
 
    wth->priv = NULL;
 
diff --git a/wiretap/catapult_dct2000.c b/wiretap/catapult_dct2000.c
index a17ab0d..b389d2a 100644
--- a/wiretap/catapult_dct2000.c
+++ b/wiretap/catapult_dct2000.c
@@ -262,7 +262,7 @@ catapult_dct2000_open(wtap *wth, int *err, gchar **err_info)
     wth->subtype_close = catapult_dct2000_close;
 
     /* Choose microseconds (have 4 decimal places...) */
-    wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+    wth->file_tsprec = WTAP_TSPREC_USEC;
 
 
     /***************************************************************/
diff --git a/wiretap/commview.c b/wiretap/commview.c
index 935d15f..f85b1c8 100644
--- a/wiretap/commview.c
+++ b/wiretap/commview.c
@@ -126,7 +126,7 @@ int commview_open(wtap *wth, int *err, gchar **err_info)
 
 	wth->file_type = WTAP_FILE_COMMVIEW;
 	wth->file_encap = WTAP_ENCAP_PER_PACKET;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 	return 1; /* Our kind of file */
 }
diff --git a/wiretap/cosine.c b/wiretap/cosine.c
index d6db197..76892b2 100644
--- a/wiretap/cosine.c
+++ b/wiretap/cosine.c
@@ -282,7 +282,7 @@ int cosine_open(wtap *wth, int *err, gchar **err_info)
 	wth->snapshot_length = 0; /* not known */
 	wth->subtype_read = cosine_read;
 	wth->subtype_seek_read = cosine_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_CSEC;
+	wth->file_tsprec = WTAP_TSPREC_CSEC;
 
 	return 1;
 }
diff --git a/wiretap/csids.c b/wiretap/csids.c
index a60fd11..30702b4 100644
--- a/wiretap/csids.c
+++ b/wiretap/csids.c
@@ -139,7 +139,7 @@ int csids_open(wtap *wth, int *err, gchar **err_info)
   wth->snapshot_length = 0; /* not known */
   wth->subtype_read = csids_read;
   wth->subtype_seek_read = csids_seek_read;
-  wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+  wth->file_tsprec = WTAP_TSPREC_SEC;
 
   return 1;
 }
diff --git a/wiretap/daintree-sna.c b/wiretap/daintree-sna.c
index a9edc71..4c79217 100644
--- a/wiretap/daintree-sna.c
+++ b/wiretap/daintree-sna.c
@@ -125,7 +125,7 @@ int daintree_sna_open(wtap *wth, int *err, gchar **err_info)
 	/* set up for file type */
 	wth->file_type = WTAP_FILE_DAINTREE_SNA;
 	wth->file_encap = WTAP_ENCAP_IEEE802_15_4_NOFCS;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 	wth->snapshot_length = 0; /* not available in header */
 
 	return 1; /* it's a Daintree file */
diff --git a/wiretap/dbs-etherwatch.c b/wiretap/dbs-etherwatch.c
index 11ab38a..cc3d0c3 100644
--- a/wiretap/dbs-etherwatch.c
+++ b/wiretap/dbs-etherwatch.c
@@ -192,7 +192,7 @@ int dbs_etherwatch_open(wtap *wth, int *err, gchar **err_info)
 	wth->snapshot_length = 0;	/* not known */
 	wth->subtype_read = dbs_etherwatch_read;
 	wth->subtype_seek_read = dbs_etherwatch_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_CSEC;
+	wth->file_tsprec = WTAP_TSPREC_CSEC;
 
 	return 1;
 }
diff --git a/wiretap/dct3trace.c b/wiretap/dct3trace.c
index e2285ec..94e1012 100644
--- a/wiretap/dct3trace.c
+++ b/wiretap/dct3trace.c
@@ -181,7 +181,7 @@ int dct3trace_open(wtap *wth, int *err, gchar **err_info)
 	wth->snapshot_length = 0; /* not known */
 	wth->subtype_read = dct3trace_read;
 	wth->subtype_seek_read = dct3trace_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+	wth->file_tsprec = WTAP_TSPREC_SEC;
 
 	return 1;
 }
diff --git a/wiretap/erf.c b/wiretap/erf.c
index 6fe4847..d762745 100644
--- a/wiretap/erf.c
+++ b/wiretap/erf.c
@@ -274,7 +274,7 @@ extern int erf_open(wtap *wth, int *err, gchar **err_info)
 
   wth->subtype_read = erf_read;
   wth->subtype_seek_read = erf_seek_read;
-  wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+  wth->file_tsprec = WTAP_TSPREC_NSEC;
 
   erf_populate_interfaces(wth);
 
@@ -698,7 +698,7 @@ int erf_dump_open(wtap_dumper *wdh, int *err)
 
   switch(wdh->file_type){
     case WTAP_FILE_ERF:
-      wdh->tsprecision = WTAP_FILE_TSPREC_NSEC;
+      wdh->tsprecision = WTAP_TSPREC_NSEC;
       break;
     default:
       *err = WTAP_ERR_UNSUPPORTED_FILE_TYPE;
diff --git a/wiretap/eyesdn.c b/wiretap/eyesdn.c
index c32f5b8..5ff55df 100644
--- a/wiretap/eyesdn.c
+++ b/wiretap/eyesdn.c
@@ -148,7 +148,7 @@ int eyesdn_open(wtap *wth, int *err, gchar **err_info)
 	wth->snapshot_length = 0; /* not known */
 	wth->subtype_read = eyesdn_read;
 	wth->subtype_seek_read = eyesdn_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 	return 1;
 }
diff --git a/wiretap/file_access.c b/wiretap/file_access.c
index cbea1af..640b867 100644
--- a/wiretap/file_access.c
+++ b/wiretap/file_access.c
@@ -357,7 +357,7 @@ wtap* wtap_open_offline(const char *filename, int *err, char **err_info,
 	wth->file_encap = WTAP_ENCAP_UNKNOWN;
 	wth->subtype_sequential_close = NULL;
 	wth->subtype_close = NULL;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 	wth->priv = NULL;
 
 	init_open_routines();
diff --git a/wiretap/hcidump.c b/wiretap/hcidump.c
index 50c37c1..f7b839f 100644
--- a/wiretap/hcidump.c
+++ b/wiretap/hcidump.c
@@ -157,7 +157,7 @@ int hcidump_open(wtap *wth, int *err, gchar **err_info)
 
 	wth->subtype_read = hcidump_read;
 	wth->subtype_seek_read = hcidump_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 	return 1;
 }
diff --git a/wiretap/i4btrace.c b/wiretap/i4btrace.c
index 5cabbfe..e0e4f4a 100644
--- a/wiretap/i4btrace.c
+++ b/wiretap/i4btrace.c
@@ -112,7 +112,7 @@ int i4btrace_open(wtap *wth, int *err, gchar **err_info)
 	i4btrace->byte_swapped = byte_swapped;
 
 	wth->file_encap = WTAP_ENCAP_ISDN;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 	return 1;
 }
diff --git a/wiretap/ipfix.c b/wiretap/ipfix.c
index 9a65680..97d4529 100644
--- a/wiretap/ipfix.c
+++ b/wiretap/ipfix.c
@@ -239,7 +239,7 @@ ipfix_open(wtap *wth, int *err, gchar **err_info)
     /* all's good, this is a IPFIX file */
     wth->file_encap = WTAP_ENCAP_RAW_IPFIX;
     wth->snapshot_length = 0;
-    wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+    wth->file_tsprec = WTAP_TSPREC_SEC;
     wth->subtype_read = ipfix_read;
     wth->subtype_seek_read = ipfix_seek_read;
     wth->subtype_close = ipfix_close;
diff --git a/wiretap/iptrace.c b/wiretap/iptrace.c
index 152e008..aad4b3c 100644
--- a/wiretap/iptrace.c
+++ b/wiretap/iptrace.c
@@ -72,13 +72,13 @@ int iptrace_open(wtap *wth, int *err, gchar **err_info)
 		wth->file_type = WTAP_FILE_IPTRACE_1_0;
 		wth->subtype_read = iptrace_read_1_0;
 		wth->subtype_seek_read = iptrace_seek_read_1_0;
-		wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+		wth->file_tsprec = WTAP_TSPREC_SEC;
 	}
 	else if (strcmp(name, "iptrace 2.0") == 0) {
 		wth->file_type = WTAP_FILE_IPTRACE_2_0;
 		wth->subtype_read = iptrace_read_2_0;
 		wth->subtype_seek_read = iptrace_seek_read_2_0;
-		wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+		wth->file_tsprec = WTAP_TSPREC_NSEC;
 	}
 	else {
 		return 0;
diff --git a/wiretap/iseries.c b/wiretap/iseries.c
index e31d5ec..8d5e111 100644
--- a/wiretap/iseries.c
+++ b/wiretap/iseries.c
@@ -250,7 +250,7 @@ iseries_open (wtap * wth, int *err, gchar ** err_info)
         wth->snapshot_length   = 0;
         wth->subtype_read      = iseries_read;
         wth->subtype_seek_read = iseries_seek_read;
-        wth->tsprecision       = WTAP_FILE_TSPREC_USEC;
+        wth->file_tsprec       = WTAP_TSPREC_USEC;
 
         if (file_seek (wth->fh, 0, SEEK_SET, err) == -1)
           {
@@ -290,7 +290,7 @@ iseries_open (wtap * wth, int *err, gchar ** err_info)
             wth->snapshot_length   = 0;
             wth->subtype_read      = iseries_read;
             wth->subtype_seek_read = iseries_seek_read;
-            wth->tsprecision       = WTAP_FILE_TSPREC_USEC;
+            wth->file_tsprec       = WTAP_TSPREC_USEC;
 
             if (file_seek (wth->fh, 0, SEEK_SET, err) == -1)
               {
diff --git a/wiretap/k12.c b/wiretap/k12.c
index 85db119..5923eb9 100644
--- a/wiretap/k12.c
+++ b/wiretap/k12.c
@@ -832,7 +832,7 @@ int k12_open(wtap *wth, int *err, gchar **err_info) {
     wth->subtype_seek_read = k12_seek_read;
     wth->subtype_close = k12_close;
     wth->priv = (void *)file_data;
-    wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+    wth->file_tsprec = WTAP_TSPREC_NSEC;
 
     return 1;
 }
diff --git a/wiretap/k12text.l b/wiretap/k12text.l
index 817eb92..fdfd3a7 100644
--- a/wiretap/k12text.l
+++ b/wiretap/k12text.l
@@ -351,7 +351,7 @@ k12text_open(wtap *wth, int *err, gchar **err_info _U_)
 	wth->snapshot_length = 0;
 	wth->subtype_read = k12text_read;
 	wth->subtype_seek_read = k12text_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+	wth->file_tsprec = WTAP_TSPREC_NSEC;
 
 	return 1;
 }
diff --git a/wiretap/lanalyzer.c b/wiretap/lanalyzer.c
index eb83872..35dad96 100644
--- a/wiretap/lanalyzer.c
+++ b/wiretap/lanalyzer.c
@@ -348,7 +348,7 @@ int lanalyzer_open(wtap *wth, int *err, gchar **err_info)
 	wth->subtype_read = lanalyzer_read;
 	wth->subtype_seek_read = lanalyzer_seek_read;
 	wth->snapshot_length = 0;
-	wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+	wth->file_tsprec = WTAP_TSPREC_NSEC;
 
 	/* Read records until we find the start of packets */
 	while (1) {
diff --git a/wiretap/libpcap.c b/wiretap/libpcap.c
index 47dafc7..5477073 100644
--- a/wiretap/libpcap.c
+++ b/wiretap/libpcap.c
@@ -107,7 +107,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		   a program using either standard or ss990417 libpcap. */
 		byte_swapped = FALSE;
 		modified = FALSE;
-		wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wth->file_tsprec = WTAP_TSPREC_USEC;
 		break;
 
 	case PCAP_MODIFIED_MAGIC:
@@ -115,7 +115,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		   a program using either ss990915 or ss991029 libpcap. */
 		byte_swapped = FALSE;
 		modified = TRUE;
-		wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wth->file_tsprec = WTAP_TSPREC_USEC;
 		break;
 
 	case PCAP_SWAPPED_MAGIC:
@@ -124,7 +124,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		   ss990417 libpcap. */
 		byte_swapped = TRUE;
 		modified = FALSE;
-		wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wth->file_tsprec = WTAP_TSPREC_USEC;
 		break;
 
 	case PCAP_SWAPPED_MODIFIED_MAGIC:
@@ -133,7 +133,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		   or ss991029 libpcap. */
 		byte_swapped = TRUE;
 		modified = TRUE;
-		wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wth->file_tsprec = WTAP_TSPREC_USEC;
 		break;
 
 	case PCAP_NSEC_MAGIC:
@@ -142,7 +142,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		   except that the time stamps have nanosecond resolution. */
 		byte_swapped = FALSE;
 		modified = FALSE;
-		wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+		wth->file_tsprec = WTAP_TSPREC_NSEC;
 		break;
 
 	case PCAP_SWAPPED_NSEC_MAGIC:
@@ -152,7 +152,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		   nanosecond resolution. */
 		byte_swapped = TRUE;
 		modified = FALSE;
-		wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+		wth->file_tsprec = WTAP_TSPREC_NSEC;
 		break;
 
 	default:
@@ -311,7 +311,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		 * precision to nanosecond precision.
 		 */
 		wth->file_type = WTAP_FILE_PCAP_AIX;
-		wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+		wth->file_tsprec = WTAP_TSPREC_NSEC;
 		return 1;
 	}
 
@@ -400,7 +400,7 @@ int libpcap_open(wtap *wth, int *err, gchar **err_info)
 		 *
 		 * Try the standard format first.
 		 */
-		if(wth->tsprecision == WTAP_FILE_TSPREC_NSEC) {
+		if(wth->file_tsprec == WTAP_TSPREC_NSEC) {
 			wth->file_type = WTAP_FILE_PCAP_NSEC;
 		} else {
 			wth->file_type = WTAP_FILE_PCAP;
@@ -662,7 +662,7 @@ static gboolean libpcap_read(wtap *wth, int *err, gchar **err_info,
 	/* Update the Timestamp, if not already done */
 	if (wth->file_encap != WTAP_ENCAP_ERF) {
 	  wth->phdr.ts.secs = hdr.hdr.ts_sec;
-	  if(wth->tsprecision == WTAP_FILE_TSPREC_NSEC) {
+	  if(wth->file_tsprec == WTAP_TSPREC_NSEC) {
 	    wth->phdr.ts.nsecs = hdr.hdr.ts_usec;
 	  } else {
 	    wth->phdr.ts.nsecs = hdr.hdr.ts_usec * 1000;
@@ -901,18 +901,18 @@ gboolean libpcap_dump_open(wtap_dumper *wdh, int *err)
 	case WTAP_FILE_PCAP_SS990417:	/* modified, but with the old magic, sigh */
 	case WTAP_FILE_PCAP_NOKIA:	/* Nokia libpcap of some sort */
 		magic = PCAP_MAGIC;
-		wdh->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wdh->tsprecision = WTAP_TSPREC_USEC;
 		break;
 
 	case WTAP_FILE_PCAP_SS990915:	/* new magic, extra crap */
 	case WTAP_FILE_PCAP_SS991029:
 		magic = PCAP_MODIFIED_MAGIC;
-		wdh->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wdh->tsprecision = WTAP_TSPREC_USEC;
 		break;
 
 	case WTAP_FILE_PCAP_NSEC:		/* same as WTAP_FILE_PCAP, but nsec precision */
 		magic = PCAP_NSEC_MAGIC;
-		wdh->tsprecision = WTAP_FILE_TSPREC_NSEC;
+		wdh->tsprecision = WTAP_TSPREC_NSEC;
 		break;
 
 	default:
@@ -966,7 +966,7 @@ static gboolean libpcap_dump(wtap_dumper *wdh,
 	phdrsize = pcap_get_phdr_size(wdh->encap, pseudo_header);
 
 	rec_hdr.hdr.ts_sec = (guint32) phdr->ts.secs;
-	if(wdh->tsprecision == WTAP_FILE_TSPREC_NSEC) {
+	if(wdh->tsprecision == WTAP_TSPREC_NSEC) {
 		rec_hdr.hdr.ts_usec = phdr->ts.nsecs;
 	} else {
 		rec_hdr.hdr.ts_usec = phdr->ts.nsecs / 1000;
diff --git a/wiretap/mime_file.c b/wiretap/mime_file.c
index 6c64d0e..d0aae88 100644
--- a/wiretap/mime_file.c
+++ b/wiretap/mime_file.c
@@ -190,7 +190,7 @@ mime_file_open(wtap *wth, int *err, gchar **err_info)
 
 	wth->file_type = WTAP_FILE_MIME;
 	wth->file_encap = WTAP_ENCAP_MIME;
-	wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+	wth->file_tsprec = WTAP_TSPREC_SEC;
 	wth->subtype_read = mime_read;
 	wth->subtype_seek_read = mime_seek_read;
 	wth->snapshot_length = 0;
diff --git a/wiretap/mp2t.c b/wiretap/mp2t.c
index 8496437..de057ba 100644
--- a/wiretap/mp2t.c
+++ b/wiretap/mp2t.c
@@ -220,7 +220,7 @@ mp2t_open(wtap *wth, int *err, gchar **err_info)
 
     wth->file_type = WTAP_FILE_MPEG_2_TS;
     wth->file_encap = WTAP_ENCAP_MPEG_2_TS;
-    wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+    wth->file_tsprec = WTAP_TSPREC_NSEC;
     wth->subtype_read = mp2t_read;
     wth->subtype_seek_read = mp2t_seek_read;
     wth->snapshot_length = 0;
diff --git a/wiretap/mpeg.c b/wiretap/mpeg.c
index 5c6710f..4545ffb 100644
--- a/wiretap/mpeg.c
+++ b/wiretap/mpeg.c
@@ -299,7 +299,7 @@ good_magic:
 
 	wth->file_type = WTAP_FILE_MPEG;
 	wth->file_encap = WTAP_ENCAP_MPEG;
-	wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+	wth->file_tsprec = WTAP_TSPREC_NSEC;
 	wth->subtype_read = mpeg_read;
 	wth->subtype_seek_read = mpeg_seek_read;
 	wth->snapshot_length = 0;
diff --git a/wiretap/netmon.c b/wiretap/netmon.c
index e53bdfc..3b3ed46 100644
--- a/wiretap/netmon.c
+++ b/wiretap/netmon.c
@@ -402,7 +402,7 @@ int netmon_open(wtap *wth, int *err, gchar **err_info)
 		 * Version 1.x of the file format supports
 		 * millisecond precision.
 		 */
-		wth->tsprecision = WTAP_FILE_TSPREC_MSEC;
+		wth->file_tsprec = WTAP_TSPREC_MSEC;
 		break;
 
 	case 2:
@@ -412,7 +412,7 @@ int netmon_open(wtap *wth, int *err, gchar **err_info)
 		 * currently support that, so say
 		 * "nanosecond precision" for now.
 		 */
-		wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+		wth->file_tsprec = WTAP_TSPREC_NSEC;
 		break;
 	}
 	return 1;
diff --git a/wiretap/netscaler.c b/wiretap/netscaler.c
index ba1126c..617b17b 100644
--- a/wiretap/netscaler.c
+++ b/wiretap/netscaler.c
@@ -651,7 +651,7 @@ int nstrace_open(wtap *wth, int *err, gchar **err_info)
         nstrace->nstrace_buf_offset = 0;
     }
 
-    wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+    wth->file_tsprec = WTAP_TSPREC_NSEC;
     wth->phdr.ts.secs = nstrace->nspm_curtime;
     wth->phdr.ts.nsecs = 0;
 
diff --git a/wiretap/netscreen.c b/wiretap/netscreen.c
index ad218af..a029dd6 100644
--- a/wiretap/netscreen.c
+++ b/wiretap/netscreen.c
@@ -184,7 +184,7 @@ int netscreen_open(wtap *wth, int *err, gchar **err_info)
 	wth->snapshot_length = 0; /* not known */
 	wth->subtype_read = netscreen_read;
 	wth->subtype_seek_read = netscreen_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_DSEC;
+	wth->file_tsprec = WTAP_TSPREC_DSEC;
 	
 	return 1;
 }
diff --git a/wiretap/nettl.c b/wiretap/nettl.c
index 757ddaa..d881eeb 100644
--- a/wiretap/nettl.c
+++ b/wiretap/nettl.c
@@ -287,7 +287,7 @@ int nettl_open(wtap *wth, int *err, gchar **err_info)
     if (file_seek(wth->fh, FILE_HDR_SIZE, SEEK_SET, err) == -1) {
 	return -1;
     }
-    wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+    wth->file_tsprec = WTAP_TSPREC_USEC;
 
     return 1;
 }
diff --git a/wiretap/network_instruments.c b/wiretap/network_instruments.c
index 3640d28..9ba7100 100644
--- a/wiretap/network_instruments.c
+++ b/wiretap/network_instruments.c
@@ -247,7 +247,7 @@ int network_instruments_open(wtap *wth, int *err, gchar **err_info)
     wth->subtype_close = NULL;
     wth->subtype_sequential_close = NULL;
     wth->snapshot_length = 0;    /* not available in header */
-    wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+    wth->file_tsprec = WTAP_TSPREC_NSEC;
     wth->file_type = WTAP_FILE_NETWORK_INSTRUMENTS;
 
     /* reset the pointer to the first packet */
diff --git a/wiretap/netxray.c b/wiretap/netxray.c
index c2af737..d4d2710 100644
--- a/wiretap/netxray.c
+++ b/wiretap/netxray.c
@@ -495,12 +495,12 @@ int netxray_open(wtap *wth, int *err, gchar **err_info)
 
 	case WTAP_FILE_NETXRAY_OLD:
 		ticks_per_sec = 1000.0;
-		wth->tsprecision = WTAP_FILE_TSPREC_MSEC;
+		wth->file_tsprec = WTAP_TSPREC_MSEC;
 		break;
 
 	case WTAP_FILE_NETXRAY_1_0:
 		ticks_per_sec = 1000.0;
-		wth->tsprecision = WTAP_FILE_TSPREC_MSEC;
+		wth->file_tsprec = WTAP_TSPREC_MSEC;
 		break;
 
 	case WTAP_FILE_NETXRAY_1_1:
@@ -511,7 +511,7 @@ int netxray_open(wtap *wth, int *err, gchar **err_info)
 		 * and older versions of Windows Sniffer.
 		 */
 		ticks_per_sec = 1000000.0;
-		wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+		wth->file_tsprec = WTAP_TSPREC_USEC;
 		break;
 
 	case WTAP_FILE_NETXRAY_2_00x:
@@ -668,9 +668,9 @@ int netxray_open(wtap *wth, int *err, gchar **err_info)
 		 * XXX - Seems reasonable to use nanosecs only if TPS >= 10M
 		 */
 		if (ticks_per_sec >= 1e7)
-			wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+			wth->file_tsprec = WTAP_TSPREC_NSEC;
 		else
-			wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+			wth->file_tsprec = WTAP_TSPREC_USEC;
 		break;
 
 	default:
diff --git a/wiretap/ngsniffer.c b/wiretap/ngsniffer.c
index f15694f..4ada82d 100644
--- a/wiretap/ngsniffer.c
+++ b/wiretap/ngsniffer.c
@@ -799,7 +799,7 @@ ngsniffer_open(wtap *wth, int *err, gchar **err_info)
 	 * isn't stored in the capture file.
 	 */
 
-	wth->tsprecision = WTAP_FILE_TSPREC_NSEC;	/* XXX */
+	wth->file_tsprec = WTAP_TSPREC_NSEC;	/* XXX */
 
 	return 1;
 }
diff --git a/wiretap/packetlogger.c b/wiretap/packetlogger.c
index eece1a0..fcaedc9 100644
--- a/wiretap/packetlogger.c
+++ b/wiretap/packetlogger.c
@@ -118,7 +118,7 @@ int packetlogger_open(wtap *wth, int *err, gchar **err_info)
 
 	wth->file_type = WTAP_FILE_PACKETLOGGER;
 	wth->file_encap = WTAP_ENCAP_PACKETLOGGER;
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 	return 1; /* Our kind of file */
 }
diff --git a/wiretap/pcapng.c b/wiretap/pcapng.c
index f652057..338be96 100644
--- a/wiretap/pcapng.c
+++ b/wiretap/pcapng.c
@@ -371,7 +371,6 @@ typedef struct wtapng_block_s {
         const union wtap_pseudo_header *pseudo_header;
         struct wtap_pkthdr *packet_header;
         const guint8 *frame_buffer;
-        int *file_encap;
 } wtapng_block_t;
 
 /* Interface data in private struct */
@@ -379,6 +378,7 @@ typedef struct interface_data_s {
         int wtap_encap;
         guint32 snap_len;
         guint64 time_units_per_second;
+        int tsprecision;
 } interface_data_t;
 
 typedef struct {
@@ -643,10 +643,12 @@ pcapng_read_section_header_block(FILE_T fh, gboolean first_block,
 
 /* "Interface Description Block" */
 static int
-pcapng_read_if_descr_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn,
-                           wtapng_block_t *wblock, int *err, gchar **err_info)
+pcapng_read_if_descr_block(wtap *wth, FILE_T fh, pcapng_block_header_t *bh,
+                           pcapng_t *pn, wtapng_block_t *wblock, int *err,
+                           gchar **err_info)
 {
-        guint64 time_units_per_second = 1000000; /* default */
+        guint64 time_units_per_second = 1000000; /* default = 10^6 */
+        int     tsprecision = WTAP_TSPREC_USEC;
         int     bytes_read;
         int     block_read;
         int to_read, opt_cont_buf_len;
@@ -690,6 +692,7 @@ pcapng_read_if_descr_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn,
 
         wblock->data.if_descr.wtap_encap = wtap_pcap_encap_to_wtap_encap(wblock->data.if_descr.link_type);
         wblock->data.if_descr.time_units_per_second = time_units_per_second;
+        wblock->data.if_descr.tsprecision = tsprecision;
 
         pcapng_debug3("pcapng_read_if_descr_block: IDB link_type %u (%s), snap %u",
                       wblock->data.if_descr.link_type,
@@ -821,7 +824,20 @@ pcapng_read_if_descr_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn,
                                 }
                                 wblock->data.if_descr.time_units_per_second = time_units_per_second;
                                 wblock->data.if_descr.if_tsresol = if_tsresol;
-                                pcapng_debug2("pcapng_read_if_descr_block: if_tsresol %u, units/s %" G_GINT64_MODIFIER "u", wblock->data.if_descr.if_tsresol, wblock->data.if_descr.time_units_per_second);
+                                if (time_units_per_second >= 1000000000)
+                                    tsprecision = WTAP_TSPREC_NSEC;
+                                else if (time_units_per_second >= 1000000)
+                                    tsprecision = WTAP_TSPREC_USEC;
+                                else if (time_units_per_second >= 1000)
+                                    tsprecision = WTAP_TSPREC_MSEC;
+                                else if (time_units_per_second >= 100)
+                                    tsprecision = WTAP_TSPREC_CSEC;
+                                else if (time_units_per_second >= 10)
+                                    tsprecision = WTAP_TSPREC_DSEC;
+                                else
+                                    tsprecision = WTAP_TSPREC_SEC;
+                                wblock->data.if_descr.tsprecision = tsprecision;
+                                pcapng_debug3("pcapng_read_if_descr_block: if_tsresol %u, units/s %" G_GINT64_MODIFIER "u, tsprecision %d", wblock->data.if_descr.if_tsresol, wblock->data.if_descr.time_units_per_second, tsprecision);
                         } else {
                                 pcapng_debug1("pcapng_read_if_descr_block: if_tsresol length %u not 1 as expected", oh.option_length);
                         }
@@ -883,12 +899,33 @@ pcapng_read_if_descr_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn,
 
         g_free(option_content);
 
-        if (*wblock->file_encap == WTAP_ENCAP_UNKNOWN) {
-                *wblock->file_encap = wblock->data.if_descr.wtap_encap;
+        /*
+         * If the per-file encapsulation isn't known, set it to this
+         * interface's encapsulation.
+         *
+         * If it *is* known, and it isn't this interface's encapsulation,
+         * set it to WTAP_ENCAP_PER_PACKET, as this file doesn't
+         * have a single encapsulation for all interfaces in the file,
+         * so it probably doesn't have a single encapsulation for all
+         * packets in the file.
+         */
+        if (wth->file_encap == WTAP_ENCAP_UNKNOWN) {
+            wth->file_encap = wblock->data.if_descr.wtap_encap;
         } else {
-                if (*wblock->file_encap != wblock->data.if_descr.wtap_encap) {
-                        *wblock->file_encap = WTAP_ENCAP_PER_PACKET;
-                }
+            if (wth->file_encap != wblock->data.if_descr.wtap_encap) {
+                wth->file_encap = WTAP_ENCAP_PER_PACKET;
+            }
+        }
+
+        /*
+         * The same applies to the per-file time stamp resolution.
+         */
+        if (wth->file_tsprec == WTAP_TSPREC_UNKNOWN) {
+            wth->file_tsprec = wblock->data.if_descr.tsprecision;
+        } else {
+            if (wth->file_tsprec != wblock->data.if_descr.tsprecision) {
+                wth->file_tsprec = WTAP_TSPREC_PER_PACKET;
+            }
         }
 
         return block_read;
@@ -1065,6 +1102,7 @@ pcapng_read_packet_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn, wta
                        pcap_get_phdr_size(int_data.wtap_encap, wblock->pseudo_header));
         wblock->packet_header->interface_id = wblock->data.packet.interface_id;
         wblock->packet_header->pkt_encap = int_data.wtap_encap;
+        wblock->packet_header->pkt_tsprec = int_data.tsprecision;
 
         memset((void *)wblock->pseudo_header, 0, sizeof(union wtap_pseudo_header));
         pseudo_header_len = pcap_process_pseudo_header(fh,
@@ -1328,6 +1366,7 @@ pcapng_read_simple_packet_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *
         wblock->packet_header->presence_flags = WTAP_HAS_CAP_LEN|WTAP_HAS_INTERFACE_ID;
         wblock->packet_header->interface_id = 0;
         wblock->packet_header->pkt_encap = int_data.wtap_encap;
+        wblock->packet_header->pkt_tsprec = int_data.tsprecision;
         wblock->packet_header->ts.secs = 0;
         wblock->packet_header->ts.nsecs = 0;
         wblock->packet_header->interface_id = 0;
@@ -1905,7 +1944,7 @@ pcapng_read_unknown_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn _U_
 
 
 static int
-pcapng_read_block(FILE_T fh, gboolean first_block, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info)
+pcapng_read_block(wtap *wth, FILE_T fh, gboolean first_block, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info)
 {
         int block_read;
         int bytes_read;
@@ -1953,7 +1992,7 @@ pcapng_read_block(FILE_T fh, gboolean first_block, pcapng_t *pn, wtapng_block_t
                         bytes_read = pcapng_read_section_header_block(fh, first_block, &bh, pn, wblock, err, err_info);
                         break;
                 case(BLOCK_TYPE_IDB):
-                        bytes_read = pcapng_read_if_descr_block(fh, &bh, pn, wblock, err, err_info);
+                        bytes_read = pcapng_read_if_descr_block(wth, fh, &bh, pn, wblock, err, err_info);
                         break;
                 case(BLOCK_TYPE_PB):
                         bytes_read = pcapng_read_packet_block(fh, &bh, pn, wblock, err, err_info, FALSE);
@@ -2043,6 +2082,7 @@ pcapng_process_idb(wtap *wth, pcapng_t *pcapng, wtapng_block_t *wblock)
         interface_data.wtap_encap = wblock->data.if_descr.wtap_encap;
         interface_data.snap_len = wblock->data.if_descr.snap_len;
         interface_data.time_units_per_second = wblock->data.if_descr.time_units_per_second;
+        interface_data.tsprecision = wblock->data.if_descr.tsprecision;
 
         g_array_append_val(pcapng->interface_data, interface_data);
         pcapng->number_of_interfaces++;
@@ -2072,11 +2112,10 @@ pcapng_open(wtap *wth, int *err, gchar **err_info)
         wblock.frame_buffer = NULL;
         wblock.pseudo_header = NULL;
         wblock.packet_header = NULL;
-        wblock.file_encap = &wth->file_encap;
 
         pcapng_debug0("pcapng_open: opening file");
         /* read first block */
-        bytes_read = pcapng_read_block(wth->fh, TRUE, &pn, &wblock, err, err_info);
+        bytes_read = pcapng_read_block(wth, wth->fh, TRUE, &pn, &wblock, err, err_info);
         if (bytes_read <= 0) {
                 pcapng_debug0("pcapng_open: couldn't read first SHB");
                 *err = file_error(wth->fh, err_info);
@@ -2110,7 +2149,7 @@ pcapng_open(wtap *wth, int *err, gchar **err_info)
 
         wth->file_encap = WTAP_ENCAP_UNKNOWN;
         wth->snapshot_length = 0;
-        wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+        wth->file_tsprec = WTAP_TSPREC_NSEC;
         pcapng = (pcapng_t *)g_malloc(sizeof(pcapng_t));
         wth->priv = (void *)pcapng;
         *pcapng = pn;
@@ -2156,7 +2195,7 @@ pcapng_open(wtap *wth, int *err, gchar **err_info)
                 if (bh.block_type != BLOCK_TYPE_IDB) {
                         break;  /* No more IDB:s */
                 }
-                bytes_read = pcapng_read_block(wth->fh, FALSE, &pn, &wblock, err, err_info);
+                bytes_read = pcapng_read_block(wth, wth->fh, FALSE, &pn, &wblock, err, err_info);
                 if (bytes_read == 0) {
                         pcapng_debug0("No more IDBs available...");
                         break;
@@ -2200,14 +2239,13 @@ pcapng_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
         wblock.frame_buffer  = buffer_start_ptr(wth->frame_buffer);
         wblock.pseudo_header = &wth->phdr.pseudo_header;
         wblock.packet_header = &wth->phdr;
-        wblock.file_encap    = &wth->file_encap;
 
         pcapng->add_new_ipv4 = wth->add_new_ipv4;
         pcapng->add_new_ipv6 = wth->add_new_ipv6;
 
         /* read next block */
         while (1) {
-                bytes_read = pcapng_read_block(wth->fh, FALSE, pcapng, &wblock, err, err_info);
+                bytes_read = pcapng_read_block(wth, wth->fh, FALSE, pcapng, &wblock, err, err_info);
                 if (bytes_read <= 0) {
                         pcapng_debug1("pcapng_read: data_offset is finally %" G_GINT64_MODIFIER "d", *data_offset);
                         pcapng_debug0("pcapng_read: couldn't read packet block");
@@ -2219,6 +2257,7 @@ pcapng_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
                 case(BLOCK_TYPE_SHB):
                         /* We don't currently support multi-section files. */
                         wth->phdr.pkt_encap = WTAP_ENCAP_UNKNOWN;
+                        wth->phdr.pkt_tsprec = WTAP_TSPREC_UNKNOWN;
                         *err = WTAP_ERR_UNSUPPORTED;
                         *err_info = g_strdup_printf("pcapng: multi-section files not currently supported.");
                         return FALSE;
@@ -2332,10 +2371,9 @@ pcapng_seek_read(wtap *wth, gint64 seek_off,
         wblock.frame_buffer = pd;
         wblock.pseudo_header = pseudo_header;
         wblock.packet_header = &wth->phdr;
-        wblock.file_encap = &wth->file_encap;
 
         /* read the block */
-        bytes_read = pcapng_read_block(wth->random_fh, FALSE, pcapng, &wblock, err, err_info);
+        bytes_read = pcapng_read_block(wth, wth->random_fh, FALSE, pcapng, &wblock, err, err_info);
         if (bytes_read <= 0) {
                 *err = file_error(wth->random_fh, err_info);
                 pcapng_debug3("pcapng_seek_read: couldn't read packet block (err=%d, errno=%d, bytes_read=%d).",
diff --git a/wiretap/peekclassic.c b/wiretap/peekclassic.c
index e8b890e..8437d34 100644
--- a/wiretap/peekclassic.c
+++ b/wiretap/peekclassic.c
@@ -354,7 +354,7 @@ peekclassic_open(wtap *wth, int *err, gchar **err_info)
 	}
 
 	wth->snapshot_length   = 0; /* not available in header */
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 	return 1;
 }
diff --git a/wiretap/peektagged.c b/wiretap/peektagged.c
index 7f178ae..712ea88 100644
--- a/wiretap/peektagged.c
+++ b/wiretap/peektagged.c
@@ -338,7 +338,7 @@ int peektagged_open(wtap *wth, int *err, gchar **err_info)
     wth->file_encap = file_encap;
     wth->subtype_read = peektagged_read;
     wth->subtype_seek_read = peektagged_seek_read;
-    wth->tsprecision = WTAP_FILE_TSPREC_NSEC;
+    wth->file_tsprec = WTAP_TSPREC_NSEC;
 
     peektagged = (peektagged_t *)g_malloc(sizeof(peektagged_t));
     wth->priv = (void *)peektagged;
diff --git a/wiretap/pppdump.c b/wiretap/pppdump.c
index 239f1a8..e3d4165 100644
--- a/wiretap/pppdump.c
+++ b/wiretap/pppdump.c
@@ -301,7 +301,7 @@ pppdump_open(wtap *wth, int *err, gchar **err_info)
 	wth->subtype_read = pppdump_read;
 	wth->subtype_seek_read = pppdump_seek_read;
 	wth->subtype_close = pppdump_close;
-	wth->tsprecision = WTAP_FILE_TSPREC_DSEC;
+	wth->file_tsprec = WTAP_TSPREC_DSEC;
 
 	state->seek_state = g_new(pppdump_t,1);
 
diff --git a/wiretap/radcom.c b/wiretap/radcom.c
index 8e9b701..719d904 100644
--- a/wiretap/radcom.c
+++ b/wiretap/radcom.c
@@ -167,7 +167,7 @@ int radcom_open(wtap *wth, int *err, gchar **err_info)
 	wth->subtype_read = radcom_read;
 	wth->subtype_seek_read = radcom_seek_read;
 	wth->snapshot_length = 0; /* not available in header, only in frame */
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 
 #if 0
 	tm.tm_year = pletohs(&start_date.year)-1900;
diff --git a/wiretap/snoop.c b/wiretap/snoop.c
index d2f765b..2da076d 100644
--- a/wiretap/snoop.c
+++ b/wiretap/snoop.c
@@ -433,7 +433,7 @@ int snoop_open(wtap *wth, int *err, gchar **err_info)
 	wth->subtype_seek_read = snoop_seek_read;
 	wth->file_encap = file_encap;
 	wth->snapshot_length = 0;	/* not available in header */
-	wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+	wth->file_tsprec = WTAP_TSPREC_USEC;
 	return 1;
 }
 
diff --git a/wiretap/tnef.c b/wiretap/tnef.c
index 3afd1d4..f352c24 100644
--- a/wiretap/tnef.c
+++ b/wiretap/tnef.c
@@ -128,7 +128,7 @@ int tnef_open(wtap *wth, int *err, gchar **err_info)
 
   wth->subtype_read = tnef_read;
   wth->subtype_seek_read = tnef_seek_read;
-  wth->tsprecision = WTAP_FILE_TSPREC_SEC;
+  wth->file_tsprec = WTAP_TSPREC_SEC;
 
   return 1;
 }
diff --git a/wiretap/toshiba.c b/wiretap/toshiba.c
index 07f00eb..f88474d 100644
--- a/wiretap/toshiba.c
+++ b/wiretap/toshiba.c
@@ -213,7 +213,7 @@ int toshiba_open(wtap *wth, int *err, gchar **err_info)
 	wth->snapshot_length = 0; /* not known */
 	wth->subtype_read = toshiba_read;
 	wth->subtype_seek_read = toshiba_seek_read;
-	wth->tsprecision = WTAP_FILE_TSPREC_CSEC;
+	wth->file_tsprec = WTAP_TSPREC_CSEC;
 
 	return 1;
 }
diff --git a/wiretap/visual.c b/wiretap/visual.c
index 59400ba..a0f9852 100644
--- a/wiretap/visual.c
+++ b/wiretap/visual.c
@@ -267,7 +267,7 @@ int visual_open(wtap *wth, int *err, gchar **err_info)
     /* Set up the pointers to the handlers for this file type */
     wth->subtype_read = visual_read;
     wth->subtype_seek_read = visual_seek_read;
-    wth->tsprecision = WTAP_FILE_TSPREC_MSEC;
+    wth->file_tsprec = WTAP_TSPREC_MSEC;
 
     /* Add Visual-specific information to the wiretap struct for later use. */
     visual = (struct visual_read_info *)g_malloc(sizeof(struct visual_read_info));
diff --git a/wiretap/vms.c b/wiretap/vms.c
index f5c440b..550a5ac 100644
--- a/wiretap/vms.c
+++ b/wiretap/vms.c
@@ -253,7 +253,7 @@ int vms_open(wtap *wth, int *err, gchar **err_info)
     wth->snapshot_length = 0; /* not known */
     wth->subtype_read = vms_read;
     wth->subtype_seek_read = vms_seek_read;
-    wth->tsprecision = WTAP_FILE_TSPREC_CSEC;
+    wth->file_tsprec = WTAP_TSPREC_CSEC;
 
     return 1;
 }
diff --git a/wiretap/vwr.c b/wiretap/vwr.c
index 0f1dbc3..881ad64 100644
--- a/wiretap/vwr.c
+++ b/wiretap/vwr.c
@@ -653,7 +653,7 @@ int vwr_open(wtap *wth, int *err, gchar **err_info)
     wth->snapshot_length = 0;
     wth->subtype_read = vwr_read;
     wth->subtype_seek_read = vwr_seek_read;
-    wth->tsprecision = WTAP_FILE_TSPREC_USEC;
+    wth->file_tsprec = WTAP_TSPREC_USEC;
 
     if (fpgaVer == vVW510021_W_FPGA) {
         wth->file_type = WTAP_FILE_VWR_80211;
diff --git a/wiretap/wtap-int.h b/wiretap/wtap-int.h
index 1c17a42..15d5102 100644
--- a/wiretap/wtap-int.h
+++ b/wiretap/wtap-int.h
@@ -69,11 +69,19 @@ struct wtap {
     int                         file_encap;    /* per-file, for those
                                                 * file formats that have
                                                 * per-file encapsulation
-                                                * types
-                                                */
-    int                         tsprecision;   /* timestamp precision of the lower 32bits
-                                                * e.g. WTAP_FILE_TSPREC_USEC
+                                                * types rather than per-packet
+						* encapsulation types
                                                 */
+    int                         file_tsprec;   /* per-file timestamp precision
+                                                * of the fractional part of
+						* the time stamp, for those
+						* file formats that have
+						* per-file timestamp
+						* precision rather than
+						* per-packet timestamp
+						* precision
+						* e.g. WTAP_TSPREC_USEC
+						*/
     wtap_new_ipv4_callback_t    add_new_ipv4;
     wtap_new_ipv6_callback_t    add_new_ipv6;
     GPtrArray                   *fast_seek;
@@ -105,7 +113,7 @@ struct wtap_dumper {
     subtype_close_func      subtype_close;
 
     int                     tsprecision;    /**< timestamp precision of the lower 32bits
-                                             * e.g. WTAP_FILE_TSPREC_USEC
+                                             * e.g. WTAP_TSPREC_USEC
                                              */
     struct addrinfo         *addrinfo_list;
     struct wtapng_section_s *shb_hdr;
diff --git a/wiretap/wtap.c b/wiretap/wtap.c
index ee0cbc2..69803d6 100644
--- a/wiretap/wtap.c
+++ b/wiretap/wtap.c
@@ -95,9 +95,9 @@ wtap_file_encap(wtap *wth)
 }
 
 int
-wtap_file_tsprecision(wtap *wth)
+wtap_file_tsprec(wtap *wth)
 {
-	return wth->tsprecision;
+	return wth->file_tsprec;
 }
 
 wtapng_section_t *
@@ -862,6 +862,8 @@ wtap_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
 	 * capture file type doesn't have to set it), and if it
 	 * *is* WTAP_ENCAP_PER_PACKET, the caller needs to set it
 	 * anyway.
+         *
+         * Do the same for the packet time stamp resolution.
 	 */
 	wth->phdr.pkt_encap = wth->file_encap;
 
diff --git a/wiretap/wtap.h b/wiretap/wtap.h
index 36674e9..b49c280 100644
--- a/wiretap/wtap.h
+++ b/wiretap/wtap.h
@@ -319,12 +319,14 @@ extern "C" {
 #define WTAP_NUM_FILE_TYPES                     wtap_get_num_file_types()
 
 /* timestamp precision (currently only these values are supported) */
-#define WTAP_FILE_TSPREC_SEC        0
-#define WTAP_FILE_TSPREC_DSEC       1
-#define WTAP_FILE_TSPREC_CSEC       2
-#define WTAP_FILE_TSPREC_MSEC       3
-#define WTAP_FILE_TSPREC_USEC       6
-#define WTAP_FILE_TSPREC_NSEC       9
+#define WTAP_TSPREC_UNKNOWN    -2
+#define WTAP_TSPREC_PER_PACKET -1
+#define WTAP_TSPREC_SEC         0
+#define WTAP_TSPREC_DSEC        1
+#define WTAP_TSPREC_CSEC        2
+#define WTAP_TSPREC_MSEC        3
+#define WTAP_TSPREC_USEC        6
+#define WTAP_TSPREC_NSEC        9
 
 /*
  * Maximum packet size we'll support.
@@ -866,7 +868,8 @@ struct wtap_pkthdr {
     struct wtap_nstime  ts;
     guint32             caplen;         /* data length in the file */
     guint32             len;            /* data length on the wire */
-    int                 pkt_encap;
+    int                 pkt_encap;      /* WTAP_ENCAP_ value for this packet */
+    int                 pkt_tsprec;     /* WTAP_TSPREC_ value for this packet */
                                         /* pcapng variables */
     guint32             interface_id;   /* identifier of the interface. */
                                         /* options */
@@ -1010,6 +1013,7 @@ typedef struct wtapng_iface_descriptions_s {
 typedef struct wtapng_if_descr_s {
     int                    wtap_encap;            /**< link_type translated to wtap_encap */
     guint64                time_units_per_second;
+    int                    tsprecision;           /**< WTAP_TSPREC_ value for this interface */
 
     /* mandatory */
     guint16                link_type;
@@ -1214,7 +1218,7 @@ int wtap_file_type(wtap *wth);
 WS_DLL_PUBLIC
 int wtap_file_encap(wtap *wth);
 WS_DLL_PUBLIC
-int wtap_file_tsprecision(wtap *wth);
+int wtap_file_tsprec(wtap *wth);
 WS_DLL_PUBLIC
 wtapng_section_t* wtap_file_get_shb_info(wtap *wth);
 WS_DLL_PUBLIC
